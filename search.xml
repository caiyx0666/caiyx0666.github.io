<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端必须知道的性能优化</title>
      <link href="xinneng/"/>
      <url>xinneng/</url>
      
        <content type="html"><![CDATA[<h1 id="前端必须知道的性能优化"><a href="#前端必须知道的性能优化" class="headerlink" title="前端必须知道的性能优化"></a>前端必须知道的性能优化</h1><h2 id="一、HTML优化"><a href="#一、HTML优化" class="headerlink" title="一、HTML优化"></a>一、HTML优化</h2><h3 id="渲染顺序"><a href="#渲染顺序" class="headerlink" title="渲染顺序"></a>渲染顺序</h3><ul><li>CSS样式表置于头部（head），css会一边加载一边渲染</li><li>JS放body后 ，JS在未加载完成之前，会阻塞渲染</li><li>使用外部的样式表和脚本，优先加载出HTML结构</li><li>关键JS、CSS代码可以内嵌在HTML中</li><li>避免使用iFrame（window 的 onload 事件需要在所有的iFrame加载完毕后（包含里面的元素）才会触发）</li><li>使用骨架屏（骨架屏就是在页面数据尚未加载前先给用户展示出页面的大致结构，直到请求数据返回后再渲染页面，补充进需要显示的数据内容）</li></ul><h2 id="二、CSS优化"><a href="#二、CSS优化" class="headerlink" title="二、CSS优化"></a>二、CSS优化</h2><h3 id="加载优化"><a href="#加载优化" class="headerlink" title="加载优化"></a>加载优化</h3><ul><li>避免使用CSS的<code>@import</code>（使用@import引入CSS会影响浏览器的并行下载，多个<code>@import</code>会导致下载顺序絮乱，推荐使用link标签来引入CSS）</li><li>避免使用通配符<code>*</code></li><li>避免使用<code>!impotant</code></li><li>优化<code>css reset</code>（css reset就是重置css默认样式）</li><li>避免使用css表达式（为了确保有效性，CSS 表达式会进行频繁的求值，这样会特别消耗性能 ）</li></ul><h3 id="动画优化"><a href="#动画优化" class="headerlink" title="动画优化"></a>动画优化</h3><ul><li>可以使用<code>transform</code>开启图形加速（使用transform可以避免重绘）</li><li>用<code>translate</code>取代left，可以避免页面重排</li></ul><h3 id="选择器优化"><a href="#选择器优化" class="headerlink" title="选择器优化"></a>选择器优化</h3><ul><li>选择器嵌套尽量不要超过三层</li><li>id选择器尽量不要嵌套</li><li>使用继承</li></ul><h3 id="体积优化"><a href="#体积优化" class="headerlink" title="体积优化"></a>体积优化</h3><ul><li>提取公共CSS</li></ul><h2 id="三、JS优化"><a href="#三、JS优化" class="headerlink" title="三、JS优化"></a>三、JS优化</h2><h3 id="运行速度"><a href="#运行速度" class="headerlink" title="运行速度"></a>运行速度</h3><ul><li>如果没有兼容问题，尽量使用原生方法</li><li>如果 if 和 else if 分支超过3个的时候尽量写成 <code>switch</code></li><li>巧用 || 和 &amp;&amp;，可以减少不必要执行的代码</li></ul><h3 id="变量优化"><a href="#变量优化" class="headerlink" title="变量优化"></a>变量优化</h3><ul><li>避免全局查找，可以将需要重复访问的属性用变量保存</li><li>防止造成内存泄漏，可以将无用的变量赋值为 <code>null</code></li></ul><h3 id="减少无用操作"><a href="#减少无用操作" class="headerlink" title="减少无用操作"></a>减少无用操作</h3><ul><li>使用防抖节流</li><li>使用事件委托取代大量事件的绑定</li></ul><h2 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h2><ul><li>尽量将多个资源合并，减少请求次数</li><li>使用CDN，加速资源请求速度</li><li>核心资源预加载</li><li>大体积资源按需加载</li><li>压缩文件大小</li><li>制作精灵图</li><li>使用浏览器缓存</li><li>使用前端缓存，如 LoaclStorage、Cookie、SessionStorage</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化、javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Set、Map、WeakSet 和 WeakMap 的区别</title>
      <link href="set-map-weakxet-weakmap/"/>
      <url>set-map-weakxet-weakmap/</url>
      
        <content type="html"><![CDATA[<h1 id="理解Set、Map、WeakSet-和-WeakMap"><a href="#理解Set、Map、WeakSet-和-WeakMap" class="headerlink" title="理解Set、Map、WeakSet 和 WeakMap"></a>理解Set、Map、WeakSet 和 WeakMap</h1><p>Set 和 Map 主要的应用场景在于 <strong>数据重组</strong> 和 <strong>数据储存</strong></p><p>Set 是一种叫做<strong>集合</strong>的数据结构，Map 是一种叫做<strong>字典</strong>的数据结构</p><h2 id="集合（Set）"><a href="#集合（Set）" class="headerlink" title="集合（Set）"></a>集合（Set）</h2><p>ES6 新增的一种新的数据结构，类似于数组，但成员是唯一且无序的，没有重复的值。</p><p><strong>Set 本身是一种构造函数，用来生成 Set 数据结构。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// &#123;1,2,3&#125;</span></span><br></pre></td></tr></table></figure><p>数组去重</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">[...new <span class="built_in">Set</span>(arr)] <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure><p>去除字符串重复字符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;abcabc&#x27;</span></span><br><span class="line">[...new <span class="built_in">Set</span>(str)].join(<span class="string">&#x27;&#x27;</span>) <span class="comment">// &#x27;abc&#x27;</span></span><br></pre></td></tr></table></figure><p>向 Set 加入值的时候，不会发生类型转换，所以<code>5</code>和<code>&quot;5&quot;</code>是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（<code>===</code>），主要的区别是向 Set 加入值时认为<code>NaN</code>等于自身，而精确相等运算符认为<code>NaN</code>不等于自身。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">arr.add(<span class="literal">NaN</span>)</span><br><span class="line">arr.add(<span class="literal">NaN</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// &#123;NaN&#125;</span></span><br></pre></td></tr></table></figure><h4 id="常用操作方法-属性"><a href="#常用操作方法-属性" class="headerlink" title="常用操作方法 / 属性"></a>常用操作方法 / 属性</h4><ul><li><code>add(value)</code>：新增，相当于 array里的push</li><li><code>delete(value)</code>：存在即删除集合中value</li><li><code>has(value)</code>：判断集合中是否存在 value</li><li><code>clear()</code>：清空集合</li><li><code>size</code>：返回<code>Set</code>实例的成员总数。 </li></ul><h4 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h4><p>Set 结构的实例有四个遍历方法，可以用于遍历对象。</p><ul><li><code>keys()</code>：返回键名的遍历器</li><li><code>values</code>：返回键值的遍历器</li><li><code>entries</code>：返回键值对的遍历器</li><li><code>forEach</code>：使用回调函数遍历每个成员</li></ul><p><strong>注意点</strong></p><p>由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以<code>keys</code>方法和<code>values</code>方法的行为完全一致。<code>entries</code>方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;red&quot;, &quot;red&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;green&quot;, &quot;green&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;blue&quot;, &quot;blue&quot;]</span></span><br></pre></td></tr></table></figure><p> <code>forEach</code>方法的参数就是一个处理函数。该函数的参数与数组的<code>forEach</code>一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。</p><p>另外，<code>forEach</code>方法还可以有第二个参数，表示绑定处理函数内部的<code>this</code>对象。</p><h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><p> WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p><p>首先，WeakSet 的成员只能是对象，而不能是其他类型的值。</p><p>其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p><p>因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。 </p><p>由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>WeakSet 是一个构造函数，可以使用<code>new</code>命令，创建 WeakSet 数据结构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>()</span><br></pre></td></tr></table></figure><p>作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有 Iterable 接口的对象，都可以作为 WeakSet 的参数。）该数组的所有成员，都会自动成为 WeakSet 实例对象的成员。</p> <!-- 遍历`Array`可以采用下标循环，遍历`Map`和`Set`就无法使用下标。为了统一集合类型，ES6标准引入了新的`iterable`类型，`Array`、`Map`和`Set`都属于`iterable`类型。--><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line"><span class="keyword">let</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(arr)</span><br><span class="line">conlose.log(ws) <span class="comment">// &#123;[1,2],[3,4]&#125;</span></span><br></pre></td></tr></table></figure><p><strong>注意点：</strong></p><p> <code>arr</code> 是一个数组，作为 <code>WeakSet</code> 构造函数的参数，<code>arr</code> 的成员会自动成为WeakSet 的成员，并且 <code>WeakSet</code> 的成员只能是对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">WeakSet</span>(arr)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used in weak set</span></span><br></pre></td></tr></table></figure><p>上述代码中的数组arr的成员不是对象，所以会报错</p><h4 id="常用操作方法。"><a href="#常用操作方法。" class="headerlink" title="常用操作方法。"></a>常用操作方法。</h4><ul><li><code>add(value)</code>：向WeakSet 实例中添加一个新成员</li><li><code>delete(value)</code>：清除 WeakSet 实例的指定成员</li><li><code>has(value)</code>：返回一个布尔值，表示某个值是否在 WeakSet 实例中</li></ul><p>WeakSet 没有<code>size</code> 和 <code>forEach</code> 属性。</p><p>WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚遍历结束，成员就取不到了。<code>WeakSet</code> 的一个用处，是储存 DOM节点，而不用担心这些节点从节点从文档移除时，会引发内存泄漏。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    ws.add(<span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  method () &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ws.has(<span class="built_in">this</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Foo.prototype.method 只能在Foo的实例上调用！&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码保证了<code>Foo</code>的实例方法，只能在<code>Foo</code>的实例上调用。这里使用 WeakSet 的好处是，<code>ws</code>对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑<code>ws</code>的引用，就不会出现内存泄漏的问题。 </p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h4 id="含义和用法："><a href="#含义和用法：" class="headerlink" title="含义和用法："></a>含义和用法：</h4><p>javascript中的对象（Object），本质上是键值对的集合，其中只能用字符串当作键。这就给它的使用带来了很大的限制</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;王五&#x27;</span></span><br><span class="line"><span class="keyword">let</span> obj &#123;</span><br><span class="line">    name: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;李四&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">obj <span class="comment">// &#123;name: &#x27;李四&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>上面的代码，我是想将变量 <code>name</code> 和字符串 <code>name</code> 同时作为键，但是因为对象中的键只能是字符串，所以前面本该是变量的name被覆盖了</p><p> 为了解决这个问题，es6提供了<code>Map</code>数据结构。它类似于对象，也是键值对的集合，但是键的不仅限于字符串。各种类型的值（包括对象）都可以当作键。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map.set([<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>],<span class="string">&#x27;我是一个数组&#x27;</span>)</span><br><span class="line">map.set(<span class="function">()=&gt;</span>&#123;&#125;,<span class="string">&#x27;我是一个函数&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://pic.downk.cc/item/5fb514e4b18d627113654465.jpg"></p><h4 id="常用操作方法-属性-1"><a href="#常用操作方法-属性-1" class="headerlink" title="常用操作方法 / 属性"></a>常用操作方法 / 属性</h4><ul><li><code>set(key)</code>：向Map中添加新元素</li><li><code>get(key)</code>：通过键值查找特定的值</li><li><code>delete(key)</code>：通过键值从Map中移除对应的数据</li><li><code>has(key)</code>：判断Map对象中是否存在key，若是有，则返回true，反之，则为false</li><li><code>clear()</code>：将这个Map中的所有元素删除</li><li><code>size</code>：返回Map对象中所包含的键值对个数 </li></ul><h4 id="遍历操作-1"><a href="#遍历操作-1" class="headerlink" title="遍历操作"></a>遍历操作</h4><p>Map 结构的实例有四个遍历方法，可以用于遍历对象。</p><ul><li><code>keys()</code>：返回键名的遍历器</li><li><code>values()</code>：返回键值的遍历器</li><li><code>entries()</code>：返回键值对的遍历器</li><li><code>forEach()</code>：使用回调函数遍历每个成员</li></ul><h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><h4 id="含义："><a href="#含义：" class="headerlink" title="含义："></a>含义：</h4><p><code>WeakMap</code>结构与<code>Map</code>结构类似，也是用于生成键值对的集合，其中的键跟<code>WeakSet</code>一样，是弱引用的。其键必须是Object类型（<code>null</code>除外），原始数据类型不可以作为key，而值可以是任意的。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line">wm.set(&#123;&#125;,<span class="string">&#x27;xxx&#x27;</span>) <span class="comment">// 不报错</span></span><br><span class="line">wm.set(<span class="number">1</span>,<span class="string">&#x27;11&#x27;</span>) <span class="comment">// Uncaught TypeError: Invalid value used as weak map key</span></span><br><span class="line">wm.set(<span class="literal">null</span>,<span class="string">&#x27;123&#x27;</span>) <span class="comment">// Uncaught TypeError: Invalid value used as weak map key</span></span><br></pre></td></tr></table></figure><p><strong>注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。</strong> </p><h4 id="常用操作方法-属性-2"><a href="#常用操作方法-属性-2" class="headerlink" title="常用操作方法 / 属性"></a>常用操作方法 / 属性</h4><ul><li><code>delete(key)</code>：通过键值从WeakMap中移除对应的数据</li><li><code>get(key)</code>：通过键值查找到特定的值</li><li><code>has(key)</code>：判断WeakMap对象中是否存在key，若是有，则返回true，反之为false</li><li><code>set(key,value)</code>：在WeakMap中设置一组键值对，并返回这个WeakMap对象</li></ul><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><ul><li>成员不能重复</li><li>只有键值，没有键名，有点类似数组</li><li>常用的方法有 add、delete、has、clear、size，遍历方法有 keys、valus、entries、forEach</li></ul><h4 id="WeakSet-1"><a href="#WeakSet-1" class="headerlink" title="WeakSet"></a>WeakSet</h4><ul><li>成员都是对象，成员都是弱引用，不被引用计数。</li><li>可以用来保存DOM节点，不容易造成内存泄漏</li><li>方法有 add、delete、has，不能遍历</li></ul><h4 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h4><ul><li>本质上是键值对的集合，类似于对象，但是其中的键不仅限于字符串</li><li>方法有 set、get、delete、has、clear、size，遍历操作有 keys、values、entries、forEach</li></ul><h4 id="WeakMap-1"><a href="#WeakMap-1" class="headerlink" title="WeakMap"></a>WeakMap</h4><ul><li>跟Map类似，但是只接受对象作为键名（null除外）。其中的键为弱引用，不被引用计数</li><li>方法有 delete、get、has、set，不能遍历</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大厂常见面试题（01）</title>
      <link href="mianshi01/"/>
      <url>mianshi01/</url>
      
        <content type="html"><![CDATA[<h2 id="写-React-Vue-项目时为什么要在列表组件中写-key，-其作用是什么？"><a href="#写-React-Vue-项目时为什么要在列表组件中写-key，-其作用是什么？" class="headerlink" title="写 React / Vue 项目时为什么要在列表组件中写 key， 其作用是什么？"></a>写 React / Vue 项目时为什么要在列表组件中写 key， 其作用是什么？</h2><p>在我们平时使用的时候，如果我们只是使用简单模板，基于这个前提，可以高效的复用节点，diff速度来看也是不带key更加快速的，因为带key在删除节点上有耗时。这就是Vue文档所说的默认模式。但是这个并不是key作用，而是没有key的情况下可以对节点就地复用，提高性能。</p><p>这种模式会带来一些隐藏的副作用，比如可能不会产生过渡效果，或者在某些节点有绑定数据（表单）状态，会出现状态错位。Vue文档也说明了</p><blockquote><p>这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时DOM状态（例如：表单输入值）的列表渲染输出</p></blockquote><h3 id="所以我们的key的作用是什么呢"><a href="#所以我们的key的作用是什么呢" class="headerlink" title="所以我们的key的作用是什么呢"></a>所以我们的key的作用是什么呢</h3><blockquote><p>key是给每一个vnode的唯一id，可以依赖key，更准确，更快的拿到oldVnode中对应的vnode节点</p></blockquote><ol><li><p>更准确</p><p>因为带key就不是就地复用，在sameNode函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更准确</p></li><li><p>更快</p><p>利用key的唯一性生成的map对象来获取对应的节点，比遍历方式更快</p></li></ol><h2 id="‘1’-‘2’-‘3’-map-parseInt-what-amp-why"><a href="#‘1’-‘2’-‘3’-map-parseInt-what-amp-why" class="headerlink" title="[‘1’, ‘2’, ‘3’].map(parseInt) what &amp; why ?"></a>[‘1’, ‘2’, ‘3’].map(parseInt) what &amp; why ?</h2><p>在做这道题之前，我们首先要先理解 <code>map</code>和<code>parseInt</code> 方法的使用。</p><h3 id="map："><a href="#map：" class="headerlink" title="map："></a>map：</h3><p>这个方法是对数组进行映射，该方法按照原始数组元素依次处理元素，返回处理之后的数组，数组中的元素为原始数组元素调用函数处理后的值</p><p>该方法可以接收一个函数作为参数，该函数带有三个参数，分别是 当前元素的值（必选）、当前元素的索引（可选）、当前元素属于的数组对象（可选）</p><h3 id="parseInt："><a href="#parseInt：" class="headerlink" title="parseInt："></a>parseInt：</h3><p>该方法可以解析一个字符串，并返回一个整数</p><p>该方法可以接收两个参数，第一个为要进行解析的字符串对象（必选）、第二个参数表示要解析的数字的基数，该值介于 2 ~ 36 之间。</p><p>如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。</p><p>如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。</p><p>当我们了解了这两个方法之后，我们就可以来解这道题了。</p><p>[‘1’, ‘2’, ‘3’].map(parseInt) 其实就是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(item,index,array)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在具体到其中的循环过程就是这样的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1&#x27;</span>,<span class="number">0</span>,[<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>])  <span class="comment">// parseInt方法只能接收两个参数，所以第三个参数其实是无效的</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;2&#x27;</span>,<span class="number">1</span>,[<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>])</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;3&#x27;</span>,<span class="number">2</span>,[<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>])</span><br></pre></td></tr></table></figure><p>所以我们的输出结果为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="literal">NaN</span>,<span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure><h2 id="什么是防抖和节流？有什么区别？如何实现？"><a href="#什么是防抖和节流？有什么区别？如何实现？" class="headerlink" title="什么是防抖和节流？有什么区别？如何实现？"></a>什么是防抖和节流？有什么区别？如何实现？</h2><p>这边有以前写的笔记，请移步这边😳 <a href="../debounce-throttle">函数防抖和函数节流</a></p><h2 id="Set、Map、WeakSet-和-WeakMap-的区别"><a href="#Set、Map、WeakSet-和-WeakMap-的区别" class="headerlink" title="Set、Map、WeakSet 和 WeakMap 的区别"></a>Set、Map、WeakSet 和 WeakMap 的区别</h2><p>请移步观看🙈</p><p><a href="../set-map-weakxet-weakmap">Set、Map、WeakSet 和 WeakMap 的区别</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型和原型链</title>
      <link href="javascript02/"/>
      <url>javascript02/</url>
      
        <content type="html"><![CDATA[<h2 id="理解原型设计模式以及JavaScript中的原型规则"><a href="#理解原型设计模式以及JavaScript中的原型规则" class="headerlink" title="理解原型设计模式以及JavaScript中的原型规则"></a>理解原型设计模式以及JavaScript中的原型规则</h2><h2 id="instanceof的底层实现原理，手动实现一个instanceof"><a href="#instanceof的底层实现原理，手动实现一个instanceof" class="headerlink" title="instanceof的底层实现原理，手动实现一个instanceof"></a>instanceof的底层实现原理，手动实现一个instanceof</h2><h2 id="实现继承的几种方式以及他们的优缺点"><a href="#实现继承的几种方式以及他们的优缺点" class="headerlink" title="实现继承的几种方式以及他们的优缺点"></a>实现继承的几种方式以及他们的优缺点</h2><h2 id="至少说出一种开源项目-如Node-中应用原型继承的案例"><a href="#至少说出一种开源项目-如Node-中应用原型继承的案例" class="headerlink" title="至少说出一种开源项目(如Node)中应用原型继承的案例"></a>至少说出一种开源项目(如Node)中应用原型继承的案例</h2><h2 id="可以描述new一个对象的详细过程，手动实现一个new操作符"><a href="#可以描述new一个对象的详细过程，手动实现一个new操作符" class="headerlink" title="可以描述new一个对象的详细过程，手动实现一个new操作符"></a>可以描述new一个对象的详细过程，手动实现一个new操作符</h2><h2 id="理解es6-class构造以及继承的底层实现原理"><a href="#理解es6-class构造以及继承的底层实现原理" class="headerlink" title="理解es6 class构造以及继承的底层实现原理"></a>理解es6 class构造以及继承的底层实现原理</h2><p>正在努力中…..</p>]]></content>
      
      
      <categories>
          
          <category> 前端学习自检清单 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量和类型</title>
      <link href="javascript01/"/>
      <url>javascript01/</url>
      
        <content type="html"><![CDATA[<h2 id="javascript规定了几种语言类型"><a href="#javascript规定了几种语言类型" class="headerlink" title="javascript规定了几种语言类型"></a>javascript规定了几种语言类型</h2><ol><li>Undefined</li><li>Null</li><li>Boolean</li><li>String</li><li>Number</li><li>Symbol</li><li>Object</li></ol><h2 id="javascript对象的底层数据结构是什么"><a href="#javascript对象的底层数据结构是什么" class="headerlink" title="javascript对象的底层数据结构是什么"></a>javascript对象的底层数据结构是什么</h2><p>js基本类型数据都是直接按值存储在栈中的(Undefined、Null、不是new出来的布尔、数字和字符串)，每种类型的数据占用的内存空间的大小是确定的，并由系统自动分配和自动释放。这样带来的好处就是，内存可以及时得到回收，相对于堆来说 ，更加容易管理内存空间。</p><p>js引用类型数据被存储于堆中 (如对象、数组、函数等，它们是通过拷贝和new出来的）。其实，说存储于堆中，也不太准确，因为，引用类型的数据的地址指针是存储于栈中的，当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后，在通过地址指针找到堆中的所需要的数据。<br>数据在内存中的存储结构，也就是物理结构，分为两种：顺序存储结构和链式存储结构。</p><p>顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。数组就是顺序存储结构的典型代表。</p><p>链式存储结构：是把数据元素存放在内存中的任意存储单元里，也就是可以把数据存放在内存的各个位置。这些数据在内存中的地址可以是连续的，也可以是不连续的。链表就是顺序存储结构的典型代表。</p><p>和顺序存储结构不同的是，链式存储结构的数据元素之间是通过指针来连接的，我们可以通使用指针来找到某个数据元素的位置，然后对这个数据元素进行一些操作。</p><p>数组和队列都可以实现栈和链表。</p><p>打个比方说一下顺序存储结构和链式存储结构的区别：</p><p>比如去银行取钱，顺序存储结构就相当于，所有的客户按照先来后到的顺序有序的的坐在大厅的椅子上（注意：是有顺序的坐着哦）。</p><p>而链式存储结构相当于，所有的客户只要一到银行，大堂经理就给他们每人一个号码，然后他们可以随便坐在哪个椅子上（随便坐，不需要按照什么顺序坐），只需要等待工作人员广播叫号即可。</p><p>而每个客户手里的号码就相当于指针，当前的指针指向下一个存储空间，这样，所有不连续的空间就可以被有顺序的按照线性连接在一起了。</p><h2 id="Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol"><a href="#Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol" class="headerlink" title="Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol"></a>Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol</h2><ul><li>Symbol 值可以作为标识符，用于对象的属性名，可以保证不会出现同名的属性。 </li><li>该属性不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有参数</span></span><br><span class="line">        <span class="keyword">let</span> p1 = <span class="built_in">Symbol</span>()</span><br><span class="line">        <span class="keyword">let</span> p2 = <span class="built_in">Symbol</span>()</span><br><span class="line">        <span class="built_in">console</span>.log(p1 === p2); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存在参数</span></span><br><span class="line">        <span class="keyword">let</span> p3 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">        <span class="keyword">let</span> p4 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(p3 === p4); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Symbol.for()，可以访问到同一个 Symbol 值</span></span><br><span class="line">        <span class="keyword">let</span> p5 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">        <span class="keyword">let</span> p6 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(p5 === p6); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="JavaScript中的变量在内存中的具体存储形式"><a href="#JavaScript中的变量在内存中的具体存储形式" class="headerlink" title="JavaScript中的变量在内存中的具体存储形式"></a>JavaScript中的变量在内存中的具体存储形式</h2><p>栈内存和堆内存<br>JavaScript中的变量分为基本类型和引用类型<br>基本类型是保存在栈内存中的简单数据段，它们的值都有固定的大小，保存在栈空间，通过按值访问</p><p>引用类型是保存在堆内存中的对象，值大小不固定，栈内存中存放的该对象的访问地址指向堆内存中的对象，JavaScript不允许直接访问堆内存中的位置，因此操作对象时，实际操作对象的引用</p><h4 id="归类如下"><a href="#归类如下" class="headerlink" title="归类如下"></a>归类如下</h4><p>基本类型：<br>Number，String，Boolean，Null，Undefined，Symbol、<br>访问：基本数据类型的值是按值访问的。<br>存储：基本类型的变量是存放在栈内存（Stack）里的。<br>引用类型： Object<br>访问：引用类型的值是按引用访问的。<br>存储：引用类型的值是保存在堆内存（Heap）中的对象（Object）<br>typeof: 经常用来检测一个变量是不是最基本的数据类型<br>instanceof: 用来判断某个构造函数的 prototype 属性所指向的对象是否存在于另外一个要检测对象的原型链上。<br>简单说就是判断一个引用类型的变量具体是不是某种类型的对象</p><h2 id="基本类型对应的内置对象，以及他们之间的装箱拆箱操作"><a href="#基本类型对应的内置对象，以及他们之间的装箱拆箱操作" class="headerlink" title="基本类型对应的内置对象，以及他们之间的装箱拆箱操作"></a>基本类型对应的内置对象，以及他们之间的装箱拆箱操作</h2><h3 id="内置对象："><a href="#内置对象：" class="headerlink" title="内置对象："></a>内置对象：</h3><p>Object是 JavaScript 中所有对象的父对象 数据封装类对象：Object、Array、Boolean、Number 和 String 其他对象：Function、Math、Date、RegExp、Error。<br>特殊的基本包装类型(String、Number、Boolean)<br>arguments: 只存在于函数内部的一个类数组对象</p><h3 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h3><p>引用类型有个特殊的基本包装类型，它包括String、Number和Boolean。</p><p>作为字符串的a可以调用方法</p><h4 id="装箱："><a href="#装箱：" class="headerlink" title="装箱："></a>装箱：</h4><p>把基本数据类型转化为对应的引用数据类型的操作，装箱分为隐式装箱和显示装箱。在《javascript高级程序设计》中有这样一句话：</p><blockquote><p>每当读取一个基本类型的时候，后台就会创建一个对应的基本包装类型对象，从而让我们能够调用一些方法来操作这些数据。(隐式装箱)</p></blockquote><h5 id="隐式装箱"><a href="#隐式装箱" class="headerlink" title="隐式装箱"></a>隐式装箱</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;sun&#x27;</span></span><br><span class="line"><span class="keyword">let</span> b = a.indexof(<span class="string">&#x27;s&#x27;</span>) <span class="comment">// 0 // 返回下标</span></span><br><span class="line"><span class="comment">// 上面代码在后台实际的步骤为：</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;sun&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> b = a.indexof(<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">a = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，a是基本类型，它不是对象，不应该具有方法，js内部进行了一些列处理（装箱)， 使得它能够调用方法。在这个基本类型上调用方法，其实是在这个基本类型对象上调用方法。这个基本类型的对象是临时的，它只存在于方法调用那一行代码执行的瞬间，执行方法后立刻被销毁。实现机制：</p><ul><li>创建String类型的一个实例；</li><li>在实例上调用指定的方法；</li><li>销毁这个实例</li></ul><h5 id="显示装箱"><a href="#显示装箱" class="headerlink" title="显示装箱"></a>显示装箱</h5><blockquote><p>通过内置对象可以对Boolean、Object、String等可以对基本类型显示装箱</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;sun&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="拆箱："><a href="#拆箱：" class="headerlink" title="拆箱："></a>拆箱：</h4><p>拆箱和装箱相反，就是把引用类型转化为基本类型的数据，通常通过引用类型的valueof()和toString（）方法实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;sun&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> age = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">24</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name) <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> age) <span class="comment">//  object</span></span><br><span class="line"><span class="comment">// 拆箱操作</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> age.valueOf()); <span class="comment">// number // 24  基本的数字类型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name.valueOf()); <span class="comment">// string  // &#x27;sun&#x27; 基本的字符类型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> age.toString()); <span class="comment">// string  // &#x27;24&#x27; 基本的字符类型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name.toString()); <span class="comment">// string  // &#x27;sun&#x27; 基本的字符类型</span></span><br></pre></td></tr></table></figure><h2 id="理解值类型和引用类型"><a href="#理解值类型和引用类型" class="headerlink" title="理解值类型和引用类型"></a>理解值类型和引用类型</h2><h3 id="值类型和引用类型有哪些"><a href="#值类型和引用类型有哪些" class="headerlink" title="值类型和引用类型有哪些"></a>值类型和引用类型有哪些</h3><p><strong>（1）值类型：</strong>string、number、boolean、null、undefined </p><p><strong>（2）引用类型：</strong>对象、数组、函数。</p><h3 id="值类型和引用类型的区别"><a href="#值类型和引用类型的区别" class="headerlink" title="值类型和引用类型的区别"></a>值类型和引用类型的区别</h3><blockquote><p>值类型 —— 引用类型</p></blockquote><ol><li>存储方式：直接存储数据本身 —— 存储的是数据的引用，数据存储在堆中</li><li>内存分配：分配在栈中 —— 分配在堆中</li><li>效率：效率高，不需要地址转换 —— 效率较低，需要进行地址转换</li><li>内存回收：使用完立即回收 —— 使用完后不立即回收，而是交给GC（垃圾回收）处理回收</li><li>赋值操作：创建一个新对象，并进行赋值 —— 对引用地址进行复制</li><li>类型拓展：不易拓展，所有类型都是密封的，所以无法派生出新的类型。 —— 具有多态的特性方便拓展</li><li>实例分配：通常是在线程栈上分配的（静态分配），但是在某些情形下可以存储在堆中。—— 总是在进程堆中分配（动态分配）</li></ol><h2 id="null和undefined的区别"><a href="#null和undefined的区别" class="headerlink" title="null和undefined的区别"></a>null和undefined的区别</h2><p><strong>null表示”没有对象”，即该处不应该有值。</strong>典型用法是： </p><ol><li>作为函数的参数，表示该函数的参数不是对象</li><li>作为对象原型链的终点。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.prototype) <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p><strong>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。</strong>典型用法是： </p><ol><li>变量被声明了，但是没有赋值时，就等于undefined。</li><li>调用函数时，应该提供的参数没有提供，该参数等于undefined。</li><li>对象没有赋值的属性，该属性的值为undefined。</li><li>函数没有返回值时，默认返回undefined</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x</span>)</span>&#123;<span class="built_in">console</span>.log(x)&#125;</span><br><span class="line">fn() <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span></span><br><span class="line">o.p <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = fn()</span><br><span class="line"><span class="built_in">console</span>.log(x) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h2 id="判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型"><a href="#判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型" class="headerlink" title="判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型"></a>判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型</h2><p>判断数据类型的方法一般可以通过：<code>typeof</code>、<code>instanceof</code>、<code>constructor</code>、<code>toString</code> 等四种常用方法 </p><ol><li><p>typeof（可以对基本类型做出准确的判断，但是引用类型就显得有点力不从心了）</p><p>typeof 返回一个数据类型的字符串，返回结果包括：<code>number</code>、<code>boolean</code>、<code>string</code>、<code>Object</code>、<code>undefined</code>、<code>function</code>等六种数据类型</p><p>typeof 可以对JS基本数据类型做出准确的判断（除了null），而对于引用类型返回的基本上都是object，其实返回object也没有错，因为所有对象的原型链最终都是指向了Object，Object是所有对象的祖宗。但当我们需要知道某个对象的具体类型时，typeof就显得有些力不从心了</p></li></ol><ol start="2"><li><p>instanceof</p><blockquote><p>判断对象和构造函数在原型链上是否有关系，如果有关系，返回真，否则返回假</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str <span class="keyword">instanceof</span> <span class="built_in">String</span>);<span class="comment">//false</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">var</span> bool = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(bool <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);<span class="comment">//false</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">var</span> num = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num <span class="keyword">instanceof</span> <span class="built_in">Number</span>);<span class="comment">//false</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">var</span> nul = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(nul <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//false</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">var</span> und = <span class="literal">undefined</span>;</span><br><span class="line"><span class="built_in">console</span>.log(und <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//false</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">var</span> oDate = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(oDate <span class="keyword">instanceof</span> <span class="built_in">Date</span>);<span class="comment">//true</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">var</span> json = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(json <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>);<span class="comment">//true</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/a/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>);<span class="comment">//true</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">var</span> fun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(fun <span class="keyword">instanceof</span> <span class="built_in">Function</span>);<span class="comment">//true</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">var</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line"><span class="built_in">console</span>.log(error <span class="keyword">instanceof</span> <span class="built_in">Error</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>从上面的运行结果我们可以看到，基本数据类型是没有检测出他们的类型，但是我们使用下面的方式创建num、str、boolean，是可以检测出类型的： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>);</span><br><span class="line"><span class="built_in">console</span>.log(num <span class="keyword">instanceof</span> <span class="built_in">Number</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;abcdef&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str <span class="keyword">instanceof</span> <span class="built_in">String</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boolean = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(boolean <span class="keyword">instanceof</span> boolean) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>constructor：查看对象对应的构造函数 </p><blockquote><p>constructor 在其对应对象的原型下面，是程序自动生成的。当我们写一个构造函数的时候，程序会自动添加：构造函数名.prototype.constructor = 构造函数名 </p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> Fn()</span><br><span class="line"><span class="comment">// fn.prototype.constructor = Fn // 在执行上面这个函数时系统自动执行这行代码</span></span><br><span class="line"><span class="built_in">console</span>.log(fn.constructor == Fn) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这个方法不能判断出 <code>undefined</code>、<code>null</code> 的类型，并且会报错，因为 null 和 undefined 是无效的对象，因此是不会有 <code>constructor</code> 存在的</p></li></ol><p>   同时我们也需要注意到的是：<strong>使用 construtor 是不保险的，因为 constrtuctor 属性是可以被修改的，会导致检测出来的结果不正确</strong></p><ol start="4"><li><p>toString</p><p>toString时Object原型对象上的一个方法，该方法默认返回其调用者（this指向的对象）的具体类型，返回的类型格式为 [object,xxx]，xxx是具体的数据类型，其中包括：</p><p>String、Number、Boolean、Undefined、Null、Function、Date、Array、RegExp、Error、HTMLDocument、…..基本上所有对象的类型都可以通过这个方法获取到</p><p>使用方法：对于Object 对象，直接调用toString()方法 就能返回 [object,Object]。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString(<span class="keyword">new</span> <span class="built_in">Object</span>())); <span class="comment">// [object,Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Array</span>())); <span class="comment">// [object,Array]</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用"><a href="#可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用" class="headerlink" title="可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用"></a>可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用</h2><blockquote><p>什么是隐式类型转换？</p><p>JavaScript 默认自动转换，没有任何警告 </p></blockquote><h3 id="隐式类型转换常见场景"><a href="#隐式类型转换常见场景" class="headerlink" title="隐式类型转换常见场景"></a>隐式类型转换常见场景</h3><p>自动转换 Boolean</p><p>例如 if 语句或者其他需要 Boolean 的地方</p><p>自动转Number</p><p>在非 Number 类型进行数学运算符 - * / 时，会先将非 Number 转换成 Number 转换成 Number 类型</p><p>+运算符要考虑字符串的情况，在进行加法运算的时候，若是两边有一个数据类型为 String，会优先将另一边也转换为String类型，进行字符串拼接</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>+<span class="string">&#x27;2&#x27;</span> <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><h2 id="出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法"><a href="#出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法" class="headerlink" title="出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法"></a>出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法</h2><p>什么是精度丢失</p><ol><li><p>两个简单浮点数相加</p><p><img src="https://pic.downk.cc/item/5faea84d1cd1bbb86bb1e4c5.jpg"></p></li><li><p>大整数运算</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9999999999999999</span> == <span class="number">10000000000000001</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="出现小数精度丢失的原因："><a href="#出现小数精度丢失的原因：" class="headerlink" title="出现小数精度丢失的原因："></a>出现小数精度丢失的原因：</h3><p>计算机的二进制实现和位数限制有些数无法有限表示。就像一些无理数不能有限表示，如圆周率 3.1415926…，1.3333… 等。 </p><p><code>JavaScript</code> 遵循 <code>IEEE 754</code>规范，二进制储存十进制的小数时不能完整的表示小数 ，所以此时只能模仿十进制进行四舍五入了，但是二进制只有 0 和 1 两个，于是变成了 0 舍 1 入。所以就造成了运算时出现误差，丢失精度。</p><h3 id="JavaScript可以存储的最大数字、最大安全数字"><a href="#JavaScript可以存储的最大数字、最大安全数字" class="headerlink" title="JavaScript可以存储的最大数字、最大安全数字"></a>JavaScript可以存储的最大数字、最大安全数字</h3><p>JS 的最大和最小安全值可以这样获得: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_SAFE_INTEGER) <span class="comment">// 9007199254740991</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.MIN_SAFE_INTEGER); <span class="comment">// -9007199254740991</span></span><br></pre></td></tr></table></figure><p>通过下面的例子，你会明白为什么大于这个值的运算是不安全的: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="built_in">Number</span>.MAX_SAFE_INTEGER +<span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x === x + <span class="number">1</span>);<span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="JavaScript处理大数字的方法、避免精度丢失的方法"><a href="#JavaScript处理大数字的方法、避免精度丢失的方法" class="headerlink" title="JavaScript处理大数字的方法、避免精度丢失的方法"></a>JavaScript处理大数字的方法、避免精度丢失的方法</h3><ol><li><p>计算小数的时候，可以先乘以100或者1000，得到一个正数，在进行运算，最后再除回来。</p></li><li><p>对于整数的话，前端出现超大整数的几率还是挺小的，但是遇到了的话也不要慌，我们可以使用 <code>BigInt</code>，它可以代表任意大小的整数，注意只能代表整数，而且也不受最大安全整数限制。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1234567890123456789</span> * <span class="number">123</span>); <span class="comment">// 151851850485185200000</span></span><br><span class="line"><span class="comment">// 这个很明显就是错误的，末位数是不可能为0的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个时候我们就可以借用 BigInt 来进行运算了</span></span><br><span class="line"><span class="built_in">console</span>.log(BigInt(<span class="number">1234567890123456789</span>) * BigInt(<span class="number">123</span>)); <span class="comment">// 151851850485185182464n</span></span><br><span class="line"><span class="comment">// 这个就是正确答案了，最后面的n是转换成 BigInt 所带来的</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端学习自检清单 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于函数防抖和函数节流的那点事</title>
      <link href="debounce-throttle/"/>
      <url>debounce-throttle/</url>
      
        <content type="html"><![CDATA[<h1 id="函数防抖和节流"><a href="#函数防抖和节流" class="headerlink" title="函数防抖和节流"></a>函数防抖和节流</h1><h2 id="函数防抖（debounce）"><a href="#函数防抖（debounce）" class="headerlink" title="函数防抖（debounce）"></a>函数防抖（debounce）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>函数防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。</p><p>简单点说就是：用户连续多次触发某个事件，则只执行最后一次</p><p>就比如我们之前敲过的 手风琴案例 如果用户鼠标轻微晃动，在某个元素上停留时间很短，则认为是用户误触发，则不执行本次事件处理函数</p><p>未添加函数防抖之前的手风琴动画</p><p><img src="https://pic.downk.cc/item/5f8596901cd1bbb86bc74d78.gif"></p><p> 根据上图，我们不难发现，在用户想移动至某个元素途中，经过了很多元素，被鼠标移入的元素都执行了动画，但这些其实都不是用户想要看到的，这就是所谓的函数抖动</p><p>添加了函数防抖之后的手风琴</p><p><img src="https://pic.downk.cc/item/5f85979d1cd1bbb86bc7ff4e.gif"></p><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>这是我们最原始的j代码</p><p>html、css部分</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">        * &#123;</span><br><span class="line">            <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">            <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="selector-tag">ul</span> &#123;</span><br><span class="line">            <span class="attribute">list-style</span>: none;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">2400px</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="selector-id">#box</span> &#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">1200px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">            <span class="attribute">border</span>: <span class="number">2px</span> solid red;</span><br><span class="line">            <span class="attribute">margin</span>: <span class="number">100px</span> auto;</span><br><span class="line">            <span class="attribute">overflow</span>: hidden;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="selector-id">#box</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">240px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">            <span class="attribute">float</span>: left;</span><br><span class="line">        &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./images/collapse/1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./images/collapse/2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./images/collapse/3.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./images/collapse/4.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./images/collapse/5.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height:150px;line-height:150px;text-align:center; color: #fff;background-color:#ccc;font-size:80px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>js部分代码</p><p>其中 animationSlow 是我封装的一个缓动动画，调用方法为 animationSlow(“需要进行动画的dom对象”,”需要进行修改的样式，是一个对象类型”)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入我们自己封装的缓动动画</span></span><br><span class="line">&lt;script src=<span class="string">&quot;./animationSlow.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#box&#x27;</span>);              <span class="comment">// 这是最外面的大盒子</span></span><br><span class="line"><span class="keyword">var</span> liList = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;#box li&#x27;</span>);     <span class="comment">// 这是里面的每一个商品</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.注册事件</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.1 li元素注册鼠标移入事件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; liList.length; i++) &#123;</span><br><span class="line">            liList[i].onmouseenter = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">//3. 排他思想 </span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; liList.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (liList[j] == <span class="built_in">this</span>) &#123;</span><br><span class="line">                        animationSlow(liList[j], &#123;</span><br><span class="line">                            width: <span class="number">800</span></span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        animationSlow(liList[j], &#123;</span><br><span class="line">                            width: <span class="number">100</span></span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.2 给box注册鼠标移出事件</span></span><br><span class="line">        box.onmouseleave = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; liList.length; j++) &#123;</span><br><span class="line">                animationSlow(liList[j], &#123;</span><br><span class="line">                    width: <span class="number">240</span></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>分析思路：</p><ol><li>声明全局变量存储定时器ID</li><li>触发事件的时候，不立即执行，而是开启定时器，过一段时间触发</li><li>用户连续触发事件的时候，清除之前的定时器，全局变量只会存储最后一次触发的事件定时器（前面的都会被清除掉，认为这是用户误操作产生抖动）</li></ol><p><strong>注意点：在定时器内部的 <code>this</code> 关键字，无条件指向window，所以我们这里要记得使用 <code>bind</code> 重新修改定时器中的 <code>this</code> 指向</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明全局变量存储定时器ID</span></span><br><span class="line"><span class="keyword">var</span> timeId = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.1 li元素注册鼠标移入事件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; liList.length; i++) &#123;</span><br><span class="line">            liList[i].onmouseenter = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 每次被触发事件前都要清除之前的定时器，保证只执行最后一次</span></span><br><span class="line">                <span class="built_in">clearInterval</span>(timeId)</span><br><span class="line">                <span class="comment">// 触发事件的时候，不立即执行，而是开启定时器，过一段时间触发</span></span><br><span class="line">                timeId = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; liList.length; j++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (liList[j] == <span class="built_in">this</span>) &#123;</span><br><span class="line">                                animationSlow(liList[j], &#123;</span><br><span class="line">                                    width: <span class="number">800</span></span><br><span class="line">                                &#125;);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                animationSlow(liList[j], &#123;</span><br><span class="line">                                    width: <span class="number">100</span></span><br><span class="line">                                &#125;);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;.bind(<span class="built_in">this</span>), <span class="number">500</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.2 给box注册鼠标移出事件</span></span><br><span class="line">        box.onmouseleave = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">            <span class="built_in">clearInterval</span>(timeId)</span><br><span class="line">            timeId = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; liList.length; j++) &#123;</span><br><span class="line">                        animationSlow(liList[j], &#123;</span><br><span class="line">                            width: <span class="number">240</span></span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;;</span><br><span class="line">            &#125;.bind(<span class="built_in">this</span>), <span class="number">500</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这样，简单的函数防抖就可以实现了</p><h3 id="封装一个简单的万能防抖函数"><a href="#封装一个简单的万能防抖函数" class="headerlink" title="封装一个简单的万能防抖函数"></a>封装一个简单的万能防抖函数</h3><ol><li><p>函数防抖需要使用定时器id，这个id不能是局部的（函数走完之后会被回收）</p></li><li><p>定时器id也不能是全局的，因为会造成全局变量污染，所以我们要尽量避免使用全局变量</p></li><li><p>解决方案：</p><p>（1）使用闭包延长局部变量生命周期，但是闭包语法很繁琐 </p><p>（2）利用函数本身也是对象，使用函数自身的静态成员来存储定时器ID</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, time</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 开启定时器之前先清除掉之前的定时器 </span></span><br><span class="line">    <span class="built_in">clearInterval</span>(debounce.timeId)</span><br><span class="line"> <span class="comment">// 开启定时器，时间间隔触发</span></span><br><span class="line">    debounce.timeId = <span class="built_in">setInterval</span>(fn, time)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就完成了一个简单的万能防抖函数的封装</p><p>我们实际使用一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; liList.length; i++) &#123;</span><br><span class="line">     liList[i].onmouseenter = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="comment">//3. 排他思想 </span></span><br><span class="line">         debounce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">             <span class="comment">// clearInterval(timeId)</span></span><br><span class="line">             <span class="comment">// timeId = setInterval(function() &#123;</span></span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; liList.length; j++) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (liList[j] == <span class="built_in">this</span>) &#123;</span><br><span class="line">                     animationSlow(liList[j], &#123;</span><br><span class="line">                         width: <span class="number">800</span></span><br><span class="line">                     &#125;);</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     animationSlow(liList[j], &#123;</span><br><span class="line">                         width: <span class="number">100</span></span><br><span class="line">                     &#125;);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;.bind(<span class="built_in">this</span>), <span class="number">500</span>)</span><br><span class="line">     &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用闭包封装一个万能防抖函数"><a href="#使用闭包封装一个万能防抖函数" class="headerlink" title="使用闭包封装一个万能防抖函数"></a>使用闭包封装一个万能防抖函数</h3><h4 id="网上常见的一个防抖函数"><a href="#网上常见的一个防抖函数" class="headerlink" title="网上常见的一个防抖函数"></a>网上常见的一个防抖函数</h4><p>这个是未防抖之前的代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height:150px;line-height:150px;text-align:center; color: #fff;background-color:#ccc;font-size:80px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> num = <span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> content = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;content&#x27;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">        content.innerHTML = num++;</span><br><span class="line">    &#125;;</span><br><span class="line">    content.onmousemove = count;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个是还未添加防抖的效果演示</p><p><img src="https://upload-images.jianshu.io/upload_images/4842858-652a8eb5c73db0c7.gif"></p><p>这是网上常见的防抖函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> timeout;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">                <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">                <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">                timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    func.apply(context, args)</span><br><span class="line">                &#125;, wait)</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>使用防抖函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content.onmousemove = debounce(count,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>添加防抖函数之后的效果</p><p><img src="https://upload-images.jianshu.io/upload_images/4842858-1f6389b9dd9e5ef9.gif"></p><p>那就让我们用网上的这个防抖函数进行试验</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; liList.length; i++) &#123;</span><br><span class="line">            liList[i].onmouseenter = debounce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">//3. 排他思想 </span></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">                <span class="comment">// clearInterval(timeId)</span></span><br><span class="line">                <span class="comment">// timeId = setInterval(function() &#123;</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; liList.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (liList[j] == <span class="built_in">this</span>) &#123;</span><br><span class="line">                        animationSlow(liList[j], &#123;</span><br><span class="line">                            width: <span class="number">800</span></span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        animationSlow(liList[j], &#123;</span><br><span class="line">                            width: <span class="number">100</span></span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">500</span>)</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>效果演示</p><p><img src="https://pic.downk.cc/item/5f8597df1cd1bbb86bc828a9.gif"></p><h5 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h5><p>我们会发现：定时器是添加了，是在 500ms 后执行，但是，为什么经过的每一个元素都会执行，而不会被清除呢？</p><p>这是因为闭包语法的特性，在我们利用 <code>for</code> 循环给每一个元素添加鼠标移入事件的时候就已经给每一个元素添加了定时器，所以，我们在这里的话，要使用函数的静态成员来存储定时器才能保证我们只声明了一个定时器，不会出现上面的情况</p><h4 id="改良后的防抖函数"><a href="#改良后的防抖函数" class="headerlink" title="改良后的防抖函数"></a>改良后的防抖函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, time</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">let</span> that = <span class="built_in">this</span></span><br><span class="line">                <span class="keyword">let</span> args = <span class="built_in">arguments</span> <span class="comment">// arguments方法可以拿到传入的所有参数,</span></span><br><span class="line">                <span class="keyword">if</span> (debounce.timeId) <span class="built_in">clearTimeout</span>(debounce.timeId);</span><br><span class="line">                debounce.timeId = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 注意我们这里其实是可以使用箭头函数的，</span></span><br><span class="line">                <span class="comment">//就可以直接使用apply方法指向this，</span></span><br><span class="line">                <span class="comment">//而不用在定时器外面存储当前的this指向</span></span><br><span class="line">                fn.apply(that, args) </span><br><span class="line">                <span class="comment">// apply方法的第一个参数是 重定向的this指向，第二个对象是 传给fn函数 的参数</span></span><br><span class="line">                &#125;, time)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>使用上面改良的防抖函数就可以实现函数防抖了，使用方法是一样的</p><h5 id="小结：-1"><a href="#小结：-1" class="headerlink" title="小结："></a>小结：</h5><h2 id="函数节流（throttle）"><a href="#函数节流（throttle）" class="headerlink" title="函数节流（throttle）"></a>函数节流（throttle）</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>限制一个函数在一定时间内只能执行一次。</p><p>简单点说就是：让一个事件，在单位时间（500ms）内，只能执行一次</p><h3 id="函数节流的作用"><a href="#函数节流的作用" class="headerlink" title="函数节流的作用"></a>函数节流的作用</h3><p>函数节流是用来限制高频事件的触发频率的，那什么是高频事件呢？</p><ul><li><p>高频事件：触发频率极高的事件。例如  <code>onmousemove</code> (鼠标移动)、<code>onscroll</code> (滚动条事件)、<code>onresize</code> (大小变化事件)</p><p>特殊情况：高频触发（事件本身不是高频，但是用户可以通过手速来实现高频触发，例如抢购按钮的疯狂点击）</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line"><span class="built_in">window</span>.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    num ++</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我被触发了&#x27;</span>+num+<span class="string">&#x27;次&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果演示</p><p><img src="https://pic.downk.cc/item/5f85982e1cd1bbb86bc8506b.gif"></p><p>你会发现：我们在浏览器中移动了一下，事件就触发了几十上百次</p><h4 id="高频事件的危害："><a href="#高频事件的危害：" class="headerlink" title="高频事件的危害："></a>高频事件的危害：</h4><ol><li>浪费资源，降低网页速度，甚至导致浏览器卡死</li></ol><p>​    由于高频事件触发非常频繁，可能1秒会执行几十次甚至上百次，如果在这些函数内部，又调用了其他函数，尤其是操作了DOM（DOM操作耗性能且可能导致浏览器出现回流），不仅会降低整个网页的运行速，甚至会造成浏览器卡死，奔溃</p><ol><li>网速堵塞</li></ol><p>​     如果在高频事件中，进行了重复的ajax请求，可能会导致请求数据出现混乱，并且还占用服务器宽带增加服务器压力（间接增加服务器成本）</p><h3 id="函数节流思路"><a href="#函数节流思路" class="headerlink" title="函数节流思路"></a>函数节流思路</h3><ol><li>声明变量 记录 当前时间</li><li>判断当前触发事件的时间间隔</li><li>时间触发成功后，存储当前时间，作为下次触发事件的参照时间</li></ol><p>拓展：这里判断时间间隔我们要用到时间戳，那什么是时间戳呢？</p><p>​           时间戳就是来统一全球的时间的一个数字，指的是格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数，是一个非常大的数字，单位是毫秒(ms)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line"><span class="built_in">window</span>.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前的时间戳</span></span><br><span class="line">    <span class="keyword">let</span> currentTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">    <span class="comment">// 判断是否已经间隔500ms</span></span><br><span class="line">    <span class="keyword">if</span>(currentTime - lastTime &gt;<span class="number">500</span>)&#123;</span><br><span class="line">        num ++</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我被触发了&#x27;</span>+num+<span class="string">&#x27;次&#x27;</span>)</span><br><span class="line">        <span class="comment">// 将当前时间作为下次触发事件的参考时间</span></span><br><span class="line">        lastTime = currentTime</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="封装一个简单的万能节流函数"><a href="#封装一个简单的万能节流函数" class="headerlink" title="封装一个简单的万能节流函数"></a>封装一个简单的万能节流函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn,time</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否存在 throttle.lastTime 不存在就声明为0，否则在使用的时候就会自动转成 NaN </span></span><br><span class="line">    <span class="keyword">if</span>(!throttle.lastTime)&#123;</span><br><span class="line">        <span class="keyword">let</span> throttle = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前的时间戳</span></span><br><span class="line">    <span class="keyword">let</span> currentTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">    <span class="keyword">if</span>(currentTime - throttle.lastTime &gt;=time) &#123;</span><br><span class="line">        fn()</span><br><span class="line">        <span class="comment">// 将当前的时间戳赋值给 throttle.lastTime 作为下次触发事件的参考时间</span></span><br><span class="line">        throttle.lastTime = currentTime</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，一个简单的万能节流函数就完成了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line"><span class="built_in">window</span>.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    throttle(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        num ++</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我被触发了&#x27;</span>+num+<span class="string">&#x27;次&#x27;</span>)</span><br><span class="line">    &#125;,<span class="number">500</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果演示</p><p><img src="https://pic.downk.cc/item/5f85999d1cd1bbb86bc92896.gif"></p><p>调用我们封装的万能节流函数，你会发现，我们在浏览器中不管你怎么移动，我们都是 在500ms内执行一次</p><h4 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h4><p>1.节流函数需要使用使用变量存储上一次触发事件，不能是局部的（函数走完就被回收）<br>2.这个变量也不能是全局的，造成全局变量污染<br>3.解决方案：利用函数本身也是对象，使用函数的静态成员来存储 上一个触发时间</p><h3 id="使用闭包封装一个万能节流函数"><a href="#使用闭包封装一个万能节流函数" class="headerlink" title="使用闭包封装一个万能节流函数"></a>使用闭包封装一个万能节流函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, time</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 外部函数声明局部变量 lastTime </span></span><br><span class="line">            <span class="keyword">let</span> lastTime = <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 获取当前的时间戳</span></span><br><span class="line">                <span class="keyword">let</span> currentTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">                <span class="keyword">if</span> (currentTime - lastTime &gt;= time) &#123;</span><br><span class="line">                    fn()</span><br><span class="line">                    <span class="comment">// 将当前的时间戳赋值给 throttle.lastTime 作为下次触发事件的参考时间</span></span><br><span class="line">                    lastTime = currentTime</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>调用使用闭包封装的节流函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onmousemove = throttle(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            num++</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;我被触发了&#x27;</span> + num + <span class="string">&#x27;次&#x27;</span>)</span><br><span class="line">        &#125;, <span class="number">500</span>)</span><br></pre></td></tr></table></figure><p>我们会发现效果都是一样的</p><p><strong>注意闭包语法的使用，需要多次使用的变量需要在外部函数声明</strong></p><h2 id="函数防抖和函数节流的简单总结"><a href="#函数防抖和函数节流的简单总结" class="headerlink" title="函数防抖和函数节流的简单总结"></a>函数防抖和函数节流的简单总结</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ol><li>函数防抖：用户多次触发事件，以最后一次为准</li><li>函数节流：限制事件的执行周期（500ms内只会执行一次</li></ol><h3 id="函数防抖与函数节流异同点-与-应用场景"><a href="#函数防抖与函数节流异同点-与-应用场景" class="headerlink" title="函数防抖与函数节流异同点 与 应用场景"></a>函数防抖与函数节流异同点 与 应用场景</h3><ol><li><p>相同点：都是为了优化 js 代码的执行频率，提高代码性能</p></li><li><p>不同点：</p><p><strong>函数防抖</strong>：由用户需求决定</p><p>​        应用场景：鼠标的移入移出，用户快速移动鼠标，应该等用户结束移动后，以最后一次为主</p><p>​                          输入框事件：验证手机号或邮箱，用户输入时不断触发键盘事件，应该等用户结束输入之                          后，以最后一次输入为准</p><p><strong>函数节流</strong>：由事件本身决定（高频事件）</p><p>​         应用场景：onscroll（滚动条事件）</p><p>​                           onmousemove（鼠标移动）</p><p>​                           特殊情况：高频触发（抢购按钮点击，本身不是高频事件，用户可以用手速实现点击高频）</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解Vue生命周期钩子函数</title>
      <link href="vueshengming/"/>
      <url>vueshengming/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue生命周期钩子函数"><a href="#Vue生命周期钩子函数" class="headerlink" title="Vue生命周期钩子函数"></a>Vue生命周期钩子函数</h1><p>附上一张带有翻译的官方图解</p><p><img src="https://pic.downk.cc/item/5fa146d31cd1bbb86bd760e3.png"></p><table><thead><tr><th align="center">钩子函数</th><th align="center">触发的时机触发的时机</th><th align="center">此阶段能干什么（可以做的事）</th></tr></thead><tbody><tr><td align="center">beforeCreated</td><td align="center">vue实例还未初始化（未挂载），数据对象data都为undefined时</td><td align="center">可以给元素添加loading动画，在页面渲染前出现的内容</td></tr><tr><td align="center">created</td><td align="center">vue实例创建完成，数据对象data有了，但是还没有挂载</td><td align="center">结束loading、请求数据</td></tr><tr><td align="center">beforeMout</td><td align="center">vue实例的$el和data都初始化了，但还是虚拟的DOM节点，即将进行挂载</td><td align="center"></td></tr><tr><td align="center">mounted</td><td align="center">Vue实例挂载完毕，数据渲染完毕</td><td align="center">配合路由钩子使用、操作动态数据、dom</td></tr><tr><td align="center">beforeUpdate</td><td align="center">data更新时触发</td><td align="center">可以拿到Vue实例改变前的状态</td></tr><tr><td align="center">update</td><td align="center">data更新时触发</td><td align="center">数据更新时，做一些处理。这些钩子触发的频率很高，尽量避免进行操作，即便操作，也要保证内部方法轻量级</td></tr><tr><td align="center">beforeDestroy</td><td align="center">组件销毁时触发，但是还没真正开始销毁</td><td align="center"></td></tr><tr><td align="center">destroyed</td><td align="center">组件销毁时触发，vue实例解除了事件监听以及和dom的绑定（无响应了），但是DOM节点依旧存在</td><td align="center">组件销毁前进行提示，清除无用的Dom节点、清除定时器</td></tr></tbody></table><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      num: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">   beforeCreate () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;==============&#x27;</span> + <span class="string">&#x27;beforeCreated&#x27;</span> + <span class="string">&#x27;===================&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;$el&#x27;</span>,<span class="built_in">this</span>.$el)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;data&#x27;</span>,<span class="built_in">this</span>.$data)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;num&#x27;</span>,<span class="built_in">this</span>.num)</span><br><span class="line">  &#125;,</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;==============&#x27;</span> + <span class="string">&#x27;created&#x27;</span> + <span class="string">&#x27;===================&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;$el&#x27;</span>,<span class="built_in">this</span>.$el)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;data&#x27;</span>,<span class="built_in">this</span>.$data)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;num&#x27;</span>,<span class="built_in">this</span>.num)</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeMount () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;==============&#x27;</span> + <span class="string">&#x27;beforeMount&#x27;</span> + <span class="string">&#x27;===================&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;$el&#x27;</span>,<span class="built_in">this</span>.$el)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;data&#x27;</span>,<span class="built_in">this</span>.$data)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;num&#x27;</span>,<span class="built_in">this</span>.num)</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;==============&#x27;</span> + <span class="string">&#x27;mounted&#x27;</span> + <span class="string">&#x27;===================&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;$el&#x27;</span>,<span class="built_in">this</span>.$el)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;data&#x27;</span>,<span class="built_in">this</span>.$data)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;num&#x27;</span>,<span class="built_in">this</span>.num)</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeUpdate () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;==============&#x27;</span> + <span class="string">&#x27;beforeUpdate&#x27;</span> + <span class="string">&#x27;===================&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;$el&#x27;</span>,<span class="built_in">this</span>.$el)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;data&#x27;</span>,<span class="built_in">this</span>.$data)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;num&#x27;</span>,<span class="built_in">this</span>.num)</span><br><span class="line">  &#125;,</span><br><span class="line">  updated () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;==============&#x27;</span> + <span class="string">&#x27;updated&#x27;</span> + <span class="string">&#x27;===================&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;$el&#x27;</span>,<span class="built_in">this</span>.$el)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;data&#x27;</span>,<span class="built_in">this</span>.$data)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;num&#x27;</span>,<span class="built_in">this</span>.num)</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestroy () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;==============&#x27;</span> + <span class="string">&#x27;beforeDestroy&#x27;</span> + <span class="string">&#x27;===================&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;$el&#x27;</span>,<span class="built_in">this</span>.$el)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;data&#x27;</span>,<span class="built_in">this</span>.$data)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;num&#x27;</span>,<span class="built_in">this</span>.num)</span><br><span class="line">  &#125;,</span><br><span class="line">  destroyed () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;==============&#x27;</span> + <span class="string">&#x27;destroyed&#x27;</span> + <span class="string">&#x27;===================&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;$el&#x27;</span>,<span class="built_in">this</span>.$el)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;data&#x27;</span>,<span class="built_in">this</span>.$data)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;num&#x27;</span>,<span class="built_in">this</span>.num)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>控制台打印结果</p></blockquote><p><img src="https://pic.downk.cc/item/5fa153841cd1bbb86bda43f1.jpg"></p><p>至于<code>destroyed</code>就不好演示了，但是有一点是一定要特别注意的</p><p>在执行<code>destroyed</code>方法后，对data的改变不会再触发周期函数，此时的vue实例已经解除了事件监听和DOM的绑定，但是dom结构依然存在。所以对于实时显示的通知型组件，在他<code>destroyed</code>之前，我们必须动手<code>removeChild()</code>删除该节点；否则节点还是存在，会影响浏览器性能，还有就是清除定时器了</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星月旅行项目总结</title>
      <link href="xingyue/"/>
      <url>xingyue/</url>
      
        <content type="html"><![CDATA[<h1 id="星月旅游项目总结"><a href="#星月旅游项目总结" class="headerlink" title="星月旅游项目总结"></a>星月旅游项目总结</h1><h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>继上次的英雄头条项目之后，感觉自身能力还是不足，于是就找了这个项目来锻炼自身，当然最终目的还是一致的，毕竟还是要恰饭的🤭</p><p><a href="http://cai-yingxiong.gitee.io/xingyue/">项目原型</a>，这个是通过码云 Page 服务部署上线的，后端使用的是 http，在谷歌浏览器中若是打不开的话，可以尝试更换浏览器试试</p><p>技术亮点：</p><ol><li><code>Nuxtjs</code>框架应用，基于<code>Vue</code>的服务器渲染技术（<code>SSR</code>）</li><li><code>Nuxtjs</code>结合<code>Element-ui</code>框架使用</li><li><code>Nuxtjs</code>(SSR)中使用富文本编辑</li><li>灵活应用本地数据存储实现交互 vuex</li><li>盖楼式跟帖模块，如何应用组件递归</li><li>高德地图实现定位</li><li>前端生成付款二维码</li><li>一个应用，能学习到3种流行的业务类型</li></ol><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul><li>Nuxtjs</li><li>Vue</li><li>Vue-router</li><li>Element-ui</li><li>Axios</li><li>Token</li><li>Vuex</li><li>高德地图</li></ul><h2 id="nuxt-ssr-简介"><a href="#nuxt-ssr-简介" class="headerlink" title="nuxt/ssr 简介"></a>nuxt/ssr 简介</h2><p>在总结项目之前，我们再来回顾一下我们的 Nuxt框架，还有我们的 SSR 是个什么东西</p><p>SSR 其实就是 Vue 的服务端渲染技术</p><p>Nuxt框架是一个可以用来做 SSR 服务端渲染 开发的框架</p><p>他们之间的关系：SSR是技术基础，Nuxt是封装</p><h3 id="什么是-ssr"><a href="#什么是-ssr" class="headerlink" title="什么是 ssr"></a>什么是 ssr</h3><p>Vue.js 是构建客户端应用程序的框架默认情况下，可以在浏览器中输入 Vue组件，进行生成DOM和操作 DOM。全部的操作都是在客户端运行，在这种情况下，生命周期 mounted 之前，看不到任何东西的，或者如果我们的客户端浏览器，禁用了JS功能的话，就会一片空白</p><p>然而，vue.js也可以将同一个vue组件在<strong>服务端直接渲染</strong>为 HTML 字符串，将它们直接发送到浏览器，最后这些静态标记“激活”为客户端上完全可交互的应用程序，这个时候即使我们的客户端浏览器禁用了JS功能，一样能看到内容，这就是SSR技术</p><p><img src="https://pic.downk.cc/item/5f9baa201cd1bbb86b19c1cb.png"></p><h3 id="为什么-要不要使用服务器端渲染-SSR-？"><a href="#为什么-要不要使用服务器端渲染-SSR-？" class="headerlink" title="为什么/要不要使用服务器端渲染 (SSR)？"></a>为什么/要不要使用服务器端渲染 (SSR)？</h3><p>与传统 SPA (单页应用程序 (Single-Page Application)) 相比，服务器端渲染 (SSR) 的优势主要在于：</p><ul><li>更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。</li><li>更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。无需等待所有的 JavaScript 都完成下载并执行，你的用户将会更快速地看到完整渲染的页面。</li></ul><p>使用服务器端渲染 (SSR) 时还需要有一些权衡之处：</p><ul><li>开发条件所限。浏览器特定的代码，只能在某些生命周期钩子函数 (lifecycle hook) 中使用；一些外部扩展库 (external library) 可能需要特殊处理，才能在服务器渲染应用程序中运行。</li><li>涉及构建设置和部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序 (SPA) 不同，服务器渲染应用程序，需要处于 Node.js server 运行环境。</li><li>更多的服务器端负载。在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 (high traffic) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</li></ul><p>在对你的应用程序使用服务器端渲染 (SSR) 之前，你应该问的第一个问题是，是否真的需要它。这主要取决于内容到达时间 (time-to-content) 对应用程序的重要程度。例如，如果你正在构建一个内部仪表盘，初始加载时的额外几百毫秒并不重要，这种情况下去使用服务器端渲染 (SSR) 将是一个小题大作之举。然而，内容到达时间 (time-to-content) 要求是绝对关键的指标，在这种情况下，服务器端渲染 (SSR) 可以帮助你实现最佳的初始加载性能。</p><h2 id="项目学习总结"><a href="#项目学习总结" class="headerlink" title="项目学习总结"></a>项目学习总结</h2><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>本次项目我们为了适应公司常见的开发模式，我们采用的一样是前后端分离的模式，多人协作开发。</p><p>我负责的部分是首页、酒店首页、国内机票的所有页面和订单页面，所以我会根据我负责的部分进行一个总结</p><h3 id="Nuxt框架和-Vue-cli-搭建的脚手架的不同之处"><a href="#Nuxt框架和-Vue-cli-搭建的脚手架的不同之处" class="headerlink" title="Nuxt框架和 Vue-cli 搭建的脚手架的不同之处"></a>Nuxt框架和 Vue-cli 搭建的脚手架的不同之处</h3><p>Nuxt框架相比较于Vue-cli创建的基础脚手架来说，进行了更深层次的封装，很多的一些配置都会有所不同，这里就简单的总结一下，也是以防后面的工作会用到 Nuxt框架而忘记了相关配置😁</p><ol><li><p>在Nuxt框架中是不存在main.js文件来进行全局配置的，我们所有的全局配置都在 <code>plugins</code> 文件夹中进行</p></li><li><p>当我们需要进行设置请求默认基准路径的使用，不需要在 <code>plugins</code> 文件夹中创建文件进行配置，只需要在我们的 <code>nuxt.config.js</code> 配置文件中进行配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios: &#123;</span><br><span class="line">    baseURL: <span class="string">&quot;你需要设置的默认基准路径&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>原本的App.vue页面也变成了 layouts 文件夹中的<code>default.vue</code></p></li><li><p>在以前的Vue项目中我们需要自己引入该页面需要用到的组件，在Nuxt我们可以通过在 <code>nuxt.config.js</code> 进行下面的配置，我们的nuxt框架就会帮我们自动引入，当然你如果喜欢自己引入需要的组件的话，也可以不用进行配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">components: <span class="literal">true</span>,</span><br></pre></td></tr></table></figure></li><li><p>我们可以在 layouts 文件夹中创建一个 <code>error.vue</code> 文件作为我们的404页面</p></li><li><p>在Nuxt框架中是不存在路由配置的，所以我们在需要进行嵌套路由的时候，我们可以将父路由设置为一个文件夹，创建一个 <code>index.vue</code> 作为我们父路由的页面，而在这个文件夹中创建的其他文件则为这个父路由的子路由</p></li></ol><h3 id="Element-ui的Form表单验证"><a href="#Element-ui的Form表单验证" class="headerlink" title="Element-ui的Form表单验证"></a>Element-ui的Form表单验证</h3><h4 id="简单逻辑验证（直接使用rules）"><a href="#简单逻辑验证（直接使用rules）" class="headerlink" title="简单逻辑验证（直接使用rules）"></a>简单逻辑验证（直接使用rules）</h4><p>实现思路</p><ol><li>html中给el-form增加 <code>:rules=&quot;rules&quot;</code></li><li>html中在el-form-item 中增加属性 <code>prop=&quot;名称&quot;</code></li><li>js中直接在data中定义rules:{}</li></ol><p>html部分</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-form</span> <span class="attr">ref</span>=<span class="string">&quot;form&quot;</span> <span class="attr">:rules</span>=<span class="string">&quot;rules&quot;</span> <span class="attr">:model</span>=<span class="string">&quot;form&quot;</span> <span class="attr">label-width</span>=<span class="string">&quot;300px&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;发货地址：&quot;</span> <span class="attr">prop</span>=<span class="string">&quot;fAdderss&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">class</span>=<span class="string">&quot;inp&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;form.fAdderss&quot;</span> <span class="attr">auto-complete</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn-add&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;</span>常用地址<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>js部分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      form: &#123;</span><br><span class="line">        fAdderss: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 校验规则</span></span><br><span class="line">      rules: &#123;</span><br><span class="line">        fAdderss: [</span><br><span class="line">        &#123; <span class="attr">required</span>: <span class="literal">true</span>, <span class="comment">//是否必填</span></span><br><span class="line">          message: <span class="string">&#x27;地址不能为空&#x27;</span>, <span class="comment">//规则</span></span><br><span class="line">          trigger: <span class="string">&#x27;blur&#x27;</span>  <span class="comment">//何事件触发</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//可以设置双重验证标准</span></span><br><span class="line">        &#123; <span class="attr">min</span>: <span class="number">3</span>, <span class="attr">max</span>: <span class="number">5</span>,  <span class="attr">message</span>: <span class="string">&#x27;长度在 3 到 5 个字符&#x27;</span>, &#125;</span><br><span class="line">      ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="自定义验证逻辑"><a href="#自定义验证逻辑" class="headerlink" title="自定义验证逻辑"></a>自定义验证逻辑</h4><p>实现思路</p><ol><li>html中给el-form增加 <code>:rules=&quot;rules&quot;</code></li><li>html中在el-form-item 中增加属性 <code>prop=&quot;名称&quot;</code></li><li>js中直接在data中在rules中的名称对应中设置 <code>validator: 验证器名称,</code></li><li>js中在data中 return之上书写验证器对应的js验证逻辑</li></ol><p>html部分</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-form</span> <span class="attr">ref</span>=<span class="string">&quot;form&quot;</span> <span class="attr">:rules</span>=<span class="string">&quot;rules&quot;</span> <span class="attr">:model</span>=<span class="string">&quot;form&quot;</span> <span class="attr">label-width</span>=<span class="string">&quot;300px&quot;</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;发货人电话&quot;</span> <span class="attr">prop</span>=<span class="string">&quot;phone&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">class</span>=<span class="string">&quot;inp&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;form.phone&quot;</span> <span class="attr">auto-complete</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>js部分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="comment">// 此处自定义校验手机号码js逻辑</span></span><br><span class="line">    <span class="keyword">var</span> phoneReg = <span class="regexp">/^[1][3,4,5,7,8][0-9]&#123;9&#125;$/</span></span><br><span class="line">    <span class="keyword">var</span> validatePhone = <span class="function">(<span class="params">rule, value, callback</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!value) &#123;</span><br><span class="line">        <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;号码不能为空!!&#x27;</span>))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!phoneReg.test(value)) &#123;</span><br><span class="line">          callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;格式有误&#x27;</span>))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          callback()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      form: &#123;    </span><br><span class="line">        phone: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 校验规则</span></span><br><span class="line">      rules: &#123;</span><br><span class="line">        <span class="comment">// 校验手机号码，主要通过validator来指定验证器名称</span></span><br><span class="line">        phone: [&#123; <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">validator</span>: validatePhone, <span class="attr">trigger</span>: <span class="string">&#x27;blur&#x27;</span> &#125;]</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="Vuex的基本使用"><a href="#Vuex的基本使用" class="headerlink" title="Vuex的基本使用"></a>Vuex的基本使用</h3><p>使用 Nuxt 创建的脚手架，Vuex的相关操作都是在 <code>store</code> 文件夹中,一般情况下都是相关的一部分数据存储在一个js文件中，进行模块化管理，而不是堆积在一个文件中</p><h4 id="state-存储数据"><a href="#state-存储数据" class="headerlink" title="state 存储数据"></a>state 存储数据</h4><p>这里是用来存储数据的</p><p>全局通过 <code>this.$store.state.state的地址.访问的数据</code> 来访问到存储在 <code>state</code> 中的数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> state = <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    userInfo: &#123;&#125;,</span><br><span class="line">    num:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    count: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    reply: &#123;</span><br><span class="line">        content: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        pics: [],</span><br><span class="line">        post: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        follow: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        replyName: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    focus: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$store.state.user.userInfo</span><br></pre></td></tr></table></figure><h4 id="mutations-处理数据"><a href="#mutations-处理数据" class="headerlink" title="mutations 处理数据"></a>mutations 处理数据</h4><p>这里是用来处理数据的，可以存储多个方法进行处理数据，但是不能执行异步的函数，每个方法都存在两个参数</p><p>第一个参数为 <code>state</code> 我们存储数据的地方，我们可以通过他来拿到我们需要处理的数据</p><p>第二个参数是 <code>data</code> 为我们处理之后的数据,也可以不使用，自己进行处理</p><p>全局通过 <code>this.$store.commit() </code> 方法调用存储在 mutations 中的方法来处理 state 中的数据，使用该方法时需要传递两个参数</p><p>第一个参数为 字符串类型，mutations所在位置 / 需要调用方法，就如：’user/setUserInfo’</p><p>第二个参数为处理之后的数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mutations = &#123;</span><br><span class="line">    setUserInfo(state, data) &#123;</span><br><span class="line">        state.userInfo = data</span><br><span class="line">    &#125;,</span><br><span class="line">    setReplyName(state, data) &#123;</span><br><span class="line">        state.reply.replyName = data;</span><br><span class="line">        state.focus = !state.focus;</span><br><span class="line">    &#125;,</span><br><span class="line">    setFollow(state, data) &#123;</span><br><span class="line">        state.reply.follow = data</span><br><span class="line">    &#125;,</span><br><span class="line">    clearReply(state) &#123;</span><br><span class="line">        state.reply.follow = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        state.reply.replyName = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$store.commit(<span class="string">&#x27;user/setUserInfo&#x27;</span>, res.data)</span><br></pre></td></tr></table></figure><h4 id="actions-处理异步函数"><a href="#actions-处理异步函数" class="headerlink" title="actions 处理异步函数"></a>actions 处理异步函数</h4><p>因为在我们的 mutations 中是无法处理异步函数，所以这个时候就要用到我们的 actions 了，但是我们处理数据一样要使用 mutations，所以一般都是与mutations配合使用</p><p>在 <code>actions</code> 中的每个函数都可以接受两个参数，第一个参数是当前的 <code>store</code> 仓库实例，第二个是调用时传入的数据，每个方法中可以返回一个数据，调用方法的使用可以通过 <code>.then</code> 回调函数来处理这个放回的值</p><p>在全局中可以通过 <code>this.$store.dispatch()</code> 来调用actions中的方法，需要传递两个参数</p><p>第一个参数是 actions 的地址 / 需要调用的方法，第二个为需要进行操作的数据</p><p>该方法存在 <code>.then</code> 回调函数，可以接受到返回值进行处理</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> actions = &#123;</span><br><span class="line">    login(store, data) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.$axios(&#123;</span><br><span class="line">            method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">            url: <span class="string">&#x27;/accounts/login&#x27;</span>,</span><br><span class="line">            data</span><br><span class="line">        &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res.data);</span><br><span class="line">            <span class="comment">// 在这里不用传数据出去可以直接调用当前的 store.commit 触发mutations 就可以了</span></span><br><span class="line">            store.commit(<span class="string">&#x27;setUserInfo&#x27;</span>, res.data)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 外面的.then如果希望获取数据</span></span><br><span class="line">        <span class="comment">// 在这个 .then 里面return数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$store.dispatch(<span class="string">&quot;user/login&quot;</span>, <span class="built_in">this</span>.form).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.$message.success(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">  <span class="built_in">this</span>.$router.back();</span><br><span class="line">  <span class="built_in">this</span>.$emit(<span class="string">&quot;logins&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="getters对数据进行计算"><a href="#getters对数据进行计算" class="headerlink" title="getters对数据进行计算"></a>getters对数据进行计算</h4><p>getters的主要作用是对state中存储的数据进行计算，然后再return出去一个新的数据，可以理解为Vue中的computed，getters的返回值会根据它的依赖项被缓存起来，且只有当它的依赖值发生变化才会被重新计算。</p><p>再全局中通过 <code>this.$store.getters[模块名,方法名]</code> 来返回一个数据，你如果想要传递一个数据过去进行处理，一样是可以的，只需要再该方法后添加一个括号，括号中添加需要传递的数据便可以传递数，然后在 <code>getters</code> 中进行接收处理即可，该方法当然也可以直接在 template 中直接调用，记得去掉 this </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getters = &#123;</span><br><span class="line">    getNum: <span class="function">(<span class="params">state</span>) =&gt;</span> <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state.num + val</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    getNumber()&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.$store.getters[<span class="string">&#x27;user/getNum&#x27;</span>](<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="Vuex的使用小结："><a href="#Vuex的使用小结：" class="headerlink" title="Vuex的使用小结："></a>Vuex的使用小结：</h4><p>这里记载的只是Vuex的基本使用，还有一些辅助函数和输出时的namespaced属性没有用到，后续在进行学习的时候会专门记载的😁</p><h3 id="页面刷新Vuex中的数据丢失问题"><a href="#页面刷新Vuex中的数据丢失问题" class="headerlink" title="页面刷新Vuex中的数据丢失问题"></a>页面刷新Vuex中的数据丢失问题</h3><h4 id="使用背景："><a href="#使用背景：" class="headerlink" title="使用背景："></a>使用背景：</h4><p>在机票列表页的侧边栏中需要展示用户浏览过的机票，在Vuex中存储的浏览过的机票信息在页面刷新之后，将不复存在，这明显是不符合用户需求的。所以我们要在页面刷新之后，Vuex中依然存在数据</p><h4 id="实现思路："><a href="#实现思路：" class="headerlink" title="实现思路："></a>实现思路：</h4><p>提到页面刷新，数据依旧存在，我第一反应就想到了 <code>localStorage</code> 和 <code>cookie </code></p><p>但是 cookie 不能储存大数据且不易读取，而且需要跟后台进行交互，所以这里使用 <code>localStorage</code>是最合适的</p><p>但是想到其他的页面上需要页面刷新之后保留的数据很多，所以我选择了将整个Vuex中的数据都存储在了 <code>localStorage</code> 中。为此我们需要下载一个第三方包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -S vuex-persistedstate</span><br></pre></td></tr></table></figure><h4 id="配置使用"><a href="#配置使用" class="headerlink" title="配置使用"></a>配置使用</h4><p>我们在下载了第三方包之后明显是需要进行配置使用的，而我们进行配置的地方从之前的 <code>main.js</code> 文件移到了 <code>plugins</code> 文件夹中，我们需要创建一个js文件进行配置，取名随意，这里我就创建一个 <code>localstorage.js</code> 文件进行演示</p><blockquote><p>plugins / localstorage.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> createPersistedState <span class="keyword">from</span> <span class="string">&#x27;vuex-persistedstate&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在所有的插件里面</span></span><br><span class="line"><span class="comment">// 如果用 export default 导出一个默认函数的话</span></span><br><span class="line"><span class="comment">// 这个函数会自动获得一个 nuxt 实例的传参</span></span><br><span class="line"><span class="comment">// export default (nuxt) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     nuxt.$axios</span></span><br><span class="line"><span class="comment">//     nuxt.store</span></span><br><span class="line"><span class="comment">//     如果只需要其中某些属性, 可以用结构的方式实现</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ( &#123; store &#125; ) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 类似window.onload</span></span><br><span class="line">    <span class="comment">// window.onNuxtReady 是页面上 nuxt 准备完毕的一个回调事件</span></span><br><span class="line">    <span class="built_in">window</span>.onNuxtReady( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 引入了插件的第三方包, 调用它实现数据持久化即可</span></span><br><span class="line">        <span class="comment">// 这个插件的用法是作者规定的</span></span><br><span class="line">        createPersistedState( &#123;</span><br><span class="line">            <span class="comment">// 这个插件的目标是将 vuex 存放到本地储存</span></span><br><span class="line">            <span class="comment">// localStorage.setItem(key, this.$store)</span></span><br><span class="line">            key: <span class="string">&quot;store&quot;</span>, <span class="comment">// 读取本地存储的数据到store</span></span><br><span class="line">        &#125; )( store )</span><br><span class="line">    &#125; )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有原来 写在 main.js new Vue() 之前的逻辑</span></span><br><span class="line"><span class="comment">// 在 nuxt 当中都可以利用插件机制实现</span></span><br><span class="line"><span class="comment">// 所有配置过的插件会自动在 实例创建前执行</span></span><br></pre></td></tr></table></figure><p>因为我们的Nuxt框架用到SSR服务端渲染，我们的插件是在服务端中调用 <code>localStorage</code> 的方法进行存储的，这明显是不行的，所以我们还需要给我们的插件配置，不在服务端执行。</p><blockquote><p>nuxt.config.js配置文件 </p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">        &#123;</span><br><span class="line">            src: <span class="string">&#x27;@/plugins/localstorage&#x27;</span>,</span><br><span class="line">            <span class="comment">// 指定这个插件不可以在服务端执行(只能等到浏览器当中再执行)</span></span><br><span class="line">            ssr: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure><h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p>这样我们就配置完成了，我们会发现我们存储在Vuex中的数据都被存储到了 <code>localStorage</code> 中，这样我们就解决了页面刷新数据丢失的情况</p><p><img src="https://pic.downk.cc/item/5f9fc2881cd1bbb86b6ecea5.png"></p><h3 id="async-await-的基本使用"><a href="#async-await-的基本使用" class="headerlink" title="async await 的基本使用"></a>async await 的基本使用</h3><h4 id="使用背景"><a href="#使用背景" class="headerlink" title="使用背景"></a>使用背景</h4><p>在酒店首页中获取酒店列表和景点数据的时候都是要依赖于城市的id才能获取，嵌套回调确实是可以实现，但是那样的话代码不整洁，后期的维护和debug也很不方便，所以就选择了使用 async 和 await 。</p><p>刚好之前使用的时候都没记载过，这次项目就大量的用到了 async、await，所以就在这里记载一下吧</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>其实 async、await 就是 <code>Promise</code> 的语法糖</p><p><code>Promise</code>主要用then函数的链式调用，一直点点点，是一种从左向右的横向写法。<code>Promise</code> 的写法还是存在一定的嵌套回调问题</p><p><code>async/await</code> 从上到下，顺序执行，就像写同步代码一样。这更符合人编写代码的习惯 </p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>在一个声明函数的时候，在前面添加上 async ，定义这是一个异步函数，然后再其中的异步函数前添加上 await，这样后面的代码会在这个异步函数执行完毕之后才会执行</p><p>wait后面接的一般是promise，返回值是promise的resolve的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    resolve(<span class="string">&#x27;大娃送完了&#x27;</span>)        <span class="comment">// 继续执行后面的代码</span></span><br><span class="line">                &#125;, <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">5</span> + <span class="number">1</span>) * <span class="number">500</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> p2 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">         <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">             resolve(<span class="string">&#x27;二娃送完了&#x27;</span>)        <span class="comment">// 继续执行后面的代码</span></span><br><span class="line">         &#125;, <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">5</span> + <span class="number">1</span>) * <span class="number">500</span>)</span><br><span class="line">     &#125;)</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> data1 = <span class="keyword">await</span> p1();</span><br><span class="line">        <span class="built_in">console</span>.log(data1);</span><br><span class="line">        <span class="keyword">const</span> data2 = <span class="keyword">await</span> p2();</span><br><span class="line">        <span class="built_in">console</span>.log(data2);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><p>我们可以很清楚的看到，我们控制台打印的先后顺序为大娃然后再是二娃最后才是我们数字1</p><p><img src="https://pic.downk.cc/item/5f9fd6211cd1bbb86b749c0a.jpg"></p><p>但是这样是无法处理错误请求的，所以我们还要使用 try、catch 来处理错误请求，这里我们来模拟一下错误</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">&#x27;大娃送完了&#x27;</span>)</span><br><span class="line">        &#125;, <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">5</span> + <span class="number">1</span>) * <span class="number">500</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> p2 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">         <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">             reject(<span class="string">&#x27;二娃还没送出去&#x27;</span>)</span><br><span class="line">         &#125;, <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">5</span> + <span class="number">1</span>) * <span class="number">500</span>)</span><br><span class="line">     &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> data1 = <span class="keyword">await</span> p1();</span><br><span class="line">        <span class="built_in">console</span>.log(data1);</span><br><span class="line">        <span class="keyword">const</span> data2 = <span class="keyword">await</span> p2();</span><br><span class="line">        <span class="built_in">console</span>.log(data2);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><p><img src="https://pic.downk.cc/item/5f9fe8ec1cd1bbb86b7a2ebb.jpg"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>团队协作之前最好先统一代码风格，不然在拉取代码的时候一推报错</li><li>想修改某个组件的样式的时候，但是官方又没有提供方法的时候，可以通过浏览器检查需要修改的组件的类名，不行就加 <code>important </code>，再不行就加 <code>/deep/</code> 穿透，尽量避免使用</li><li>查文档能力还有待提高…..高德地图API的坑是真的多🤬</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue.js </tag>
            
            <tag> 项目总结 </tag>
            
            <tag> Nuxt.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>英雄头条项目总结</title>
      <link href="yxtoutiao/"/>
      <url>yxtoutiao/</url>
      
        <content type="html"><![CDATA[<h1 id="英雄头条（移动端）的一些感悟"><a href="#英雄头条（移动端）的一些感悟" class="headerlink" title="英雄头条（移动端）的一些感悟"></a>英雄头条（移动端）的一些感悟</h1><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>英雄头条是一个通用信息平台，致力于连接人与信息，让优质丰富的信息得到高效精准的分发，促使信息创造价值。</p><p>英雄头条目前拥有推荐引擎、搜索引擎、关注订阅和内容运营等多种分发方式，囊括图文、视频、问答等多种内容体裁，并涵盖科技、体育、健康、美食、教育等多个内容领域。</p><p>英雄头条包括移动端前台浏览文章、个人中心、评论等页面。Pc端后台管理文章、发布文章、编辑文章等。</p><h3 id="项目原型"><a href="#项目原型" class="headerlink" title="项目原型"></a>项目原型</h3><p><a href="http://cai-yingxiong.gitee.io/yxtoutiao/#/">英雄头条前台</a>这个通过码云部署到线上的页面，如果免费试用过期的话，可以尝试打开通过手机打开<a href="https://caiyx0666.github.io/toutiao/dist/index.html#/">这个</a>😜,因为是使用GitHub Page 服务部署到线上的，GitHub Page 是不支持使用 http 的，所以在Pc端的话可能是打不开的😱</p><p><strong>英雄头条后台因为线上的服务器数据的错乱这里就不展示了</strong>😳</p><h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><ul><li>Vue</li><li>Vue-router</li><li>Element-ui</li><li>Vue2Editor 富文本编辑器</li><li>Vant</li><li>Axios</li><li>Token</li></ul><h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>因为接触Vue的时间不长，不久前刚学习完Vue的基本使用，所以想通过该项目来加深对Vue框架的了解，其目的也是为了学习vue框架的使用，使我能从中学习到很多以后工作有用的东西，一切都是为了工作！！！💪</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>这是一个使用 <code>Vue-cli</code> 脚手架创建的项目，因为之前已经系统的学习过Vue的基本使用了，所以这里就不介绍的那么详细，就简单的总结一下通过这个项目学习到的东西和难点🤭</p><h3 id="路由守卫-导航守卫"><a href="#路由守卫-导航守卫" class="headerlink" title="路由守卫(导航守卫)"></a>路由守卫(导航守卫)</h3><p>官方解释：  正如其名，<code>vue-router</code> 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。有多种机会植入路由导航过程中：全局的, 单个路由独享的, 或者组件级的。 </p><h4 id="使用背景"><a href="#使用背景" class="headerlink" title="使用背景"></a>使用背景</h4><p>在我们登录进到一个需要 <code>token</code> 权限的网站的时候，如果本地的 token 值被删除，或者是通过另外的方法进入到该页面时，我们需要用到路由守卫，路由守卫可以理解为<strong>页面跳转之前</strong>的拦截手段，可以在拦截时判断验证用户信息，再决定是否允许用户跳转到该页面。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>在  <code>src/main.js</code>  文件里注册一个 router.beforeEach  全局前置守卫</p><p><strong>目标:</strong> 使用路由守卫, 每当跳转到个人中心的时候, 先校验 token 如果没有,重定向到登录页</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span>        <span class="comment">// 需引入router</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入了 router 以后就可以创建路由守卫</span></span><br><span class="line"><span class="comment">// beforeEach 是全局前置守卫，会拦截所有的页面跳转</span></span><br><span class="line"><span class="comment">// 接受一个回调函数作为参数，对调转进行处理</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 这个函数默认有三个参数</span></span><br><span class="line">    <span class="comment">// to 目的地的路由配置</span></span><br><span class="line">    <span class="comment">// from  来源路由配置</span></span><br><span class="line">    <span class="comment">// next  正常继续下面操作的放行函数</span></span><br><span class="line">    <span class="comment">// 判断要跳转到的页面是否为个人主页</span></span><br><span class="line">    <span class="keyword">if</span> (to.path == <span class="string">&#x27;/personage&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断本地是否存在 token</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;token&#x27;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 有登录就放行</span></span><br><span class="line">            next()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有登录就跳转到登录页</span></span><br><span class="line">            router.push(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不是跳转到个人主页就不管</span></span><br><span class="line">        next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这是在个人中心页退出到登录页时通过在导航卫士中打印的 <code>to</code> 的信息</p><p><img src="https://pic.downk.cc/item/5f8a41471cd1bbb86bebcb8a.png"></p><p><strong>注意点：</strong></p><p>守卫方法接收三个参数：</p><ul><li>to：代表要跳转到哪个路由（页面），我们可以通过 <code>to.path</code> 获取要跳转到的页面的地址，</li><li>from：代表从哪个路由跳转过来，<code>from.path</code> 一样可以拿到从哪个页面跳转过来的地址</li><li>next：是一个函数，必须要调用才能跳转到下一个页面，不调用则不跳转,所以一定要记得next()<ul><li>next() : 表示正常跳转到下一页</li><li><strong>(新版不能这么用)</strong>  next(“/login”) 表示重定向到指定的页面 </li><li>最新的路由, 重定向可以使用 router.push (不在组件内就没有 this.$router 了)</li></ul></li></ul><p><strong>补充</strong>:</p><p>在我们的项目中有很多个页面都是需要有权限 <code>token</code> 才能进入，所以我们这里要对 <code>to.path</code> 进行多次验证，但是像上述方法一样的话就显得代码有点冗余了，这里的话，我想到了两种方法：</p><p>第一种：</p><p>通过将所有需要进行验证的页面全都放在一个数组中，再判断 <code>to.path</code> 是否存在该数组当中即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 将所有需要校验的页面提出来，变成一个数组管理</span></span><br><span class="line">        <span class="comment">// 2、只需要判断 to.path 是否存在于数组中即可</span></span><br><span class="line">        <span class="keyword">const</span> pageNeedAuth = [</span><br><span class="line">            <span class="string">&#x27;/personage&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;/compile&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">        <span class="keyword">if</span> (pageNeedAuth.indexOf(to.path) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;token&#x27;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 有登录就放行</span></span><br><span class="line">            next()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有登录就跳转到登录页</span></span><br><span class="line">            router.push(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不是跳转到个人主页就不管</span></span><br><span class="line">        next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>第二种：</p><p>我们可以通过利用路由 meta 属性，配置是否需要登录的选项，如果要登录就设置 needAuth == true</p><p><code>src/router/index.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        path: <span class="string">&#x27;/personage&#x27;</span>, <span class="comment">// 个人中心</span></span><br><span class="line">        name: <span class="string">&#x27;Personage&#x27;</span>,</span><br><span class="line">        component: Personage,</span><br><span class="line">        meta: &#123;</span><br><span class="line">            needAuth: <span class="literal">true</span>  <span class="comment">// 需要验证</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p><code>src/main.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 利用路由 meta 属性，配置是否需要登录的选项</span></span><br><span class="line">    <span class="comment">// 判断是否需要验证</span></span><br><span class="line">    <span class="keyword">if</span> (to.path.needAuth) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;token&#x27;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 有登录就放行</span></span><br><span class="line">            next()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有登录就跳转到登录页</span></span><br><span class="line">            router.push(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不是跳转到个人主页就不管</span></span><br><span class="line">        next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样就可以，这两种方法效果都是一样的，但是个人感觉第二种方法会方便一点，比较这样的话，在进行路由配置的时候就可以对其进行需要验证的设置了，不用再找到 <code>main.js</code> 文件的路由导航部分进行添加了🤭</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结:"></a>小结:</h4><ol><li>创建路由守卫</li><li>在回调中校验权限 (是否有 token)</li><li>如果有 token 合法访问, return next();</li><li>如果没有就是非法访问, return  router.push({path:’/login’}) 跳转到登录页</li><li>最后在整个路由守卫的最下方必须有一个 next() 用来处理其他页面的情况</li><li>每个页面都会执行全局守卫</li></ol><h3 id="axios设置默认基准路径"><a href="#axios设置默认基准路径" class="headerlink" title="axios设置默认基准路径"></a>axios设置默认基准路径</h3><h4 id="使用背景-1"><a href="#使用背景-1" class="headerlink" title="使用背景"></a>使用背景</h4><p>每次发送请求的时候都要添加服务器地址的问题：</p><ol><li>重复、太麻烦了…</li><li>假如有一天,你的服务器搬迁了, 换服务器了, 比如从在线的变成本地的 http:127.0.0.1:3000，维护起来就很麻烦</li></ol><h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h4><p>我们可以提取请求的统一的服务器域名的部分进行抽离设置</p><p>在 <code>main.js</code> 文件中 里面设置 <code>axios.defaults.baseURL</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axios.dafaults.baseURL = <span class="string">&#x27;http://157.122.54.189:9083&#x27;</span>    <span class="comment">// 在线的服务器</span></span><br><span class="line"><span class="comment">// axios.dafaults.baseURL = &#x27;http://127.0.0.1：3000&#x27;        // 本地服务器</span></span><br></pre></td></tr></table></figure><p>这样，我们在发送请求的时候，就不用再写服务器地址了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$axios(&#123;</span><br><span class="line">url:<span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">data:&#123;&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="axios拦截器"><a href="#axios拦截器" class="headerlink" title="axios拦截器"></a>axios拦截器</h3><p>在请求或响应被 <code>then</code> 或 <code>catch</code> 函数处理前拦截它们</p><h4 id="使用背景-2"><a href="#使用背景-2" class="headerlink" title="使用背景"></a>使用背景</h4><p>如果用户使用错误的 <code>token</code> 绕过了全局导航守卫，进入了页面，页面会发送请求，如果响应的是用户信息验证失败，就应该在页面内部进行跳转，如果每个页面都这么写的话，就比较烦。而且，在我们发送请求的时候，大多都是要经过验证的，也就是在发送请求的时候，需要在请求头 <code>headers</code> 中添加验证信息 <code>token</code> ,但是每个请求都写就显得有点烦人了🤯，所以这里用我们 axios 的拦截器来做再合适不过了。</p><h4 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h4><p>附上图解</p><p><img src="https://pic.downk.cc/item/5f8a42f11cd1bbb86bec344e.png"></p><p><code>src/main.js</code> 文件中</p><ol><li>因为需要统一处理错误, 所以是全局的, 再 main.js 当中声明拦截器</li><li><code>axios.interceptors.resquest.use()</code>声明一个请求拦截器, 可以接受一个回调函数做参数, 带有请求数据 config ， 响应拦截器的声明方法只要将上述方法中的 <code>request</code> 更改为 <code>response</code> 就可以了，一样可以接收一个回调函数做参数，带有响应数据 res</li><li>拦截器拦截数据, 处理后必须放行 (return)</li><li>将我们的错误逻辑从 .then 抽离出来放到响应拦截器里面</li></ol><h5 id="请求拦截器"><a href="#请求拦截器" class="headerlink" title="请求拦截器"></a>请求拦截器</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里可以接收一个形参，拿到当前请求的配置</span></span><br><span class="line">    <span class="comment">// 如果本地存在 token 并且 请求数据中没有设置 token 就拦截下来给请求头添加 token</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;token&#x27;</span>) &amp;&amp; !config.headers.Authorization) &#123;</span><br><span class="line">        config.headers.Authorization = <span class="string">&quot;Bearer &quot;</span> + <span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 继续发送请求</span></span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="响应拦截器"><a href="#响应拦截器" class="headerlink" title="响应拦截器"></a>响应拦截器</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// res 为发送请求后返回的数据</span></span><br><span class="line">    <span class="comment">// 判断进来的用户是否有权限</span></span><br><span class="line">    <span class="keyword">if</span> (res.data.message == <span class="string">&#x27;用户信息验证失败&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 清除错误数据，再跳转</span></span><br><span class="line">        <span class="built_in">localStorage</span>.clear()</span><br><span class="line">        router.replace(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 除了明确用户信息验证失败跳转到登录页以外</span></span><br><span class="line">    <span class="comment">// 还可以封装其他的通用处理，比如 状态码 statusCode 是以4开头的三位数的请求</span></span><br><span class="line">    <span class="comment">// 不知道如何处理的情况下，只需统一将 message 给提示出来就可以了</span></span><br><span class="line">    <span class="comment">// 统一处理发送请求错误</span></span><br><span class="line">    <span class="keyword">const</span> reg = <span class="regexp">/^4\d&#123;2&#125;$/</span></span><br><span class="line">    <span class="keyword">if</span> (reg.test(res.data.statusCode)) &#123;</span><br><span class="line">        Toast.fail(res.data.message)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>注意点</strong></p><ol><li><p><code>src/main.js</code> 文件中如果想使用 vant 组件的话，因为之前的配置是全局的，在这里是不能用的，所以要单独引入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Toast &#125; from &#39;vant&#39;</span><br></pre></td></tr></table></figure></li><li><p>在不知道是否为错误的情况下，检查 res.data.statusCode 如果存在并且是 4 开头的三位数, 那么就可以证明出错</p></li><li><p>记得处理拦截后必须放行, 不然就卡死在这了</p></li><li><p><strong>导航守卫(路由守卫) 跟 响应拦截器 容易混淆, 但是作用很不一样, 特别是生效时间点</strong></p></li></ol><p><img src="https://pic.downk.cc/item/5f8a41f41cd1bbb86bebf5ea.png"></p><h3 id="首页Tab-标签页和文章组件的使用"><a href="#首页Tab-标签页和文章组件的使用" class="headerlink" title="首页Tab 标签页和文章组件的使用"></a>首页Tab 标签页和文章组件的使用</h3><p>这里首页的主要内容是依靠 Vant 组件库中的Tab标签页组件 配合 自己封装的文章组件完成的。这里还添加了 Vant组件库的 List组件，实现下拉加载更多功能，并做了优化处理，所以自己认为对初学者的我还是有一定的难度的😁</p><p>这里附上 <a href="https://youzan.github.io/vant/#/zh-CN/">Vant组件库的地址</a></p><p>这是我自己封装的首页文章组件</p><p>忽略其中的样式和 js 部分</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">&quot;$router.push(`/postdetail?id=$&#123;postData.id&#125;`)&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 专门显示单图片新闻 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 1. type == 1</span></span><br><span class="line"><span class="comment">      2. cover.length &gt;=1 &amp;&amp; &lt; 3 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">            </span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">&quot;singleNews&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">v-if</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">                postData.type == 1 &amp;&amp;</span></span></span><br><span class="line"><span class="tag"><span class="string">                postData.cover.length &gt;= 1 &amp;&amp;</span></span></span><br><span class="line"><span class="tag"><span class="string">                postData.cover.length &lt; 3</span></span></span><br><span class="line"><span class="tag"><span class="string">            &quot;</span></span></span><br><span class="line"><span class="tag">        &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span></span><br><span class="line">                    &#123;&#123; postData.title &#125;&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">                    &#123;&#123; postData.user.nickname &#125;&#125;</span><br><span class="line">                    &#123;&#123; postData.comment_length &#125;&#125; 跟帖</span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;fnFixImgUrl(postData.cover[0].url)&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cover&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 专门显示多图片新闻 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 1. type == 1</span></span><br><span class="line"><span class="comment">      2. cover.length &gt;= 3 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">            </span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">&quot;multipNews&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">v-if</span>=<span class="string">&quot;postData.type == 1 &amp;&amp; postData.cover.length &gt;= 3&quot;</span></span></span><br><span class="line"><span class="tag">        &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span>&#123;&#123; postData.title &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;coversWrapper&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;cover&quot;</span> <span class="attr">:src</span>=<span class="string">&quot;fnFixImgUrl(postData.cover[0].url)&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;cover&quot;</span> <span class="attr">:src</span>=<span class="string">&quot;fnFixImgUrl(postData.cover[1].url)&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;cover&quot;</span> <span class="attr">:src</span>=<span class="string">&quot;fnFixImgUrl(postData.cover[2].url)&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">                &#123;&#123; postData.user.nickname &#125;&#125; &#123;&#123; postData.comment_length &#125;&#125; 跟帖</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 专门显示视频 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 1. type == 2</span></span><br><span class="line"><span class="comment">      2. 封面最少有一张 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">            </span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">&quot;singleVideo&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">v-if</span>=<span class="string">&quot;postData.type == 2 &amp;&amp; postData.cover.length &gt;= 1&quot;</span></span></span><br><span class="line"><span class="tag">        &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span>&#123;&#123; postData.title &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;coverWrapper&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;fnFixImgUrl(postData.cover[0].url)&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cover&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;iconfont iconshipin&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">                &#123;&#123; postData.user.nickname &#125;&#125; &#123;&#123; postData.comment_length &#125;&#125; 跟帖</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>想要让我们的组件显示只要传入一个 <code>postData</code> 单个文章数据就能渲染出来，配合我们 Vant 中的tab标签页组件使用正常渲染问题都不大，</p><h4 id="问题说明"><a href="#问题说明" class="headerlink" title="问题说明"></a>问题说明</h4><p>但是也存在一个致命的问题，那就是，我们每一次切换页面都要发送请求，不管是否浏览过该栏目都会再次发送请求，这样的话，对服务器造成的负担会比较大。所以，这里要进行一下优化</p><p>实现方法：</p><ol><li><p>在页面获取所有的栏目时，在给每一个栏目数据添加一个空的数组来放置相应的文章列表数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">getcategoryList()&#123;</span><br><span class="line">      <span class="built_in">this</span>.$axios(&#123;</span><br><span class="line">        url:<span class="string">&#x27;/category&#x27;</span>     <span class="comment">// 获取所有的栏目数据</span></span><br><span class="line">      &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.categoryList = res.data.data.map(<span class="function"><span class="params">category</span> =&gt;</span>&#123;</span><br><span class="line">          <span class="keyword">return</span>&#123;</span><br><span class="line">            ...category,</span><br><span class="line">            <span class="comment">// 在获取文章分类时添加 postList空数组来存储文章列表数组</span></span><br><span class="line">            postList: [],</span><br><span class="line">            pageIndex:<span class="number">1</span>, <span class="comment">// 当前页数</span></span><br><span class="line">            pageSize:<span class="number">5</span>,  <span class="comment">// 每页数据条数</span></span><br><span class="line">            loading:<span class="literal">false</span>,  <span class="comment">// 当前是否在加载中</span></span><br><span class="line">            finished:<span class="literal">false</span>, <span class="comment">// 是否加载完毕</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">         <span class="comment">// 加载相应的文章数据</span></span><br><span class="line">        <span class="built_in">this</span>.loadPost()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure></li><li><p>在每次激活该栏目的时候，在获取到相应的文章数据时，就将相应的文章数据添加到相应的栏目生成的空数组 <code>postList</code> 中,如果有新的文章就将新的数据拼接在之前的数据后面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">loadPost()&#123;</span><br><span class="line">      <span class="built_in">this</span>.$axios(&#123;</span><br><span class="line">        url:<span class="string">&#x27;/post&#x27;</span>,</span><br><span class="line">        params:&#123;</span><br><span class="line">          <span class="comment">// 传入文章分类的id</span></span><br><span class="line">          category:<span class="built_in">this</span>.curCate.id,</span><br><span class="line">          pageIndex:<span class="built_in">this</span>.curCate.pageIndex, <span class="comment">// 当前页数</span></span><br><span class="line">          pageSize:<span class="built_in">this</span>.curCate.pageSize, </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 将获取到的文章列表添加到文章分类中对应的位置中去</span></span><br><span class="line">        <span class="built_in">this</span>.curCate.postList = [</span><br><span class="line">          ...this.curCate.postList,</span><br><span class="line">          ...res.data.data</span><br><span class="line">        ]</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure></li><li><p>在我们监听到了分类栏目发生变化的时候，我们要进行相应的判断，当前栏目分类的 <code>postList</code> 是否存在文章列表数据，若是不存在，再发送请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">activeIndex()&#123;</span><br><span class="line">       <span class="comment">// 这里检测到分类切换，加载新分类数据</span></span><br><span class="line">        <span class="comment">// 但是，由于我们已经分栏目管理数据了</span></span><br><span class="line">        <span class="comment">// 只有文章不存在时才会发送请求获取文章列表</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.curCate.postList.length == <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="built_in">this</span>.loadPost()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样，我们就可以达到我们要的效果了🤭</p></li></ol><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>其实这个在完成项目完成之后，回过头来看就觉得也不是很难，主要是数据有点复杂，一层套一层，刚开始敲的时候很难理清楚。索性最后还是理清楚了🤭</p><h3 id="递归组件实现评论模块"><a href="#递归组件实现评论模块" class="headerlink" title="递归组件实现评论模块"></a>递归组件实现评论模块</h3><p>说起递归组件，对于一个初学者还是有一定的威慑力的😜，这里作为回顾的话，就把递归也一起复习一下吧</p><h4 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a>什么是递归</h4><p>递归就是一个函数直接或间接的调用自己，我们在使用的时候一定要让它能够停下来，否则停不下来的话会出事喔🤭</p><h4 id="什么是递归组件"><a href="#什么是递归组件" class="headerlink" title="什么是递归组件"></a>什么是递归组件</h4><p>其实递归组件跟递归是差不多的，只是递归是函数自身的调用，而递归组件则是组件在满足一定的条件下组件内部调用自身，话不多说，直接上代码👇</p><p><img src="https://pic.downk.cc/item/5f8a42251cd1bbb86bec0247.png"></p><p><img src="https://pic.downk.cc/item/5f8a42431cd1bbb86bec089a.png"></p><h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><p>这是我们从服务器拿到的数据还有我们要实现的样式，一个评论里面还有可能在嵌套多一个评论数据 <code>parent</code> 。所以我们的递归组件的条件便是这个 <code>parent</code> 是否存在，又考虑到这个最外部的主评论的样式中还包括了其他的一些样式，所以我们这里就创建了两个组件，一个父组件编写最外层的主评论，子组件来完成评论内部的递归组件。父组件中嵌套子组件，来完成我们的评论列表的渲染</p><p>子组件结构如下👇</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parentWrapper&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">Parent</span> <span class="attr">v-if</span>=<span class="string">&quot;parentData.parent&quot;</span> <span class="attr">:parentData</span>=<span class="string">&quot;parentData.parent&quot;</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;name&quot;</span>&gt;</span>&#123;&#123; parentData.user.nickname &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;date&quot;</span>&gt;</span>3小时前<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;btnReply&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;headleClick&quot;</span>&gt;</span>回复<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ParentContent&quot;</span>&gt;</span></span><br><span class="line">              &#123;&#123; parentData.content &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意点</strong></p><p>组件内部调用自身，要记得给自身设置 <code>name</code> 属性</p><h3 id="事件总线EventBus"><a href="#事件总线EventBus" class="headerlink" title="事件总线EventBus"></a>事件总线EventBus</h3><h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><p>在Vue中可以使用 <code>EventBus</code> 来作为沟通桥梁的概念，就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件，所以组件都可以上下平行地通知其他组件，但也就是太方便所以若使用不慎，就会造成难以维护的灾难，因此才需要更完善的Vuex作为状态管理中心，将通知的概念上升到共享状态层次 </p><h4 id="使用背景-3"><a href="#使用背景-3" class="headerlink" title="使用背景"></a>使用背景</h4><p>由于递归组件的多层嵌套，我们在完成评论的发布功能的时候传递数据和响应事件就显的特别麻烦，但是这个时候我还没有学习vuex，所以就使用到了事件总线 <code>EventBus</code> </p><h4 id="使用方法-3"><a href="#使用方法-3" class="headerlink" title="使用方法"></a>使用方法</h4><ol><li>创建事件总线并将其导出，以便其它模块可以使用或者监听它。我们可以通过两种方式来实现。先来看第一种，新创建一个js文件，比如 <code>eventBus.js</code> ,第二种方法就是直接在 <code>main.js</code> 文件中初始化 <code>eventBus</code></li></ol><p>   <code>ulit/eventBus.js</code></p>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里创建一个 vue 实例</span></span><br><span class="line"><span class="comment">// 作为公共事件总线 eventBus</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> eventBus = <span class="keyword">new</span> Vue()</span><br><span class="line"><span class="comment">// 将这个实例导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> eventBus</span><br></pre></td></tr></table></figure><p>   <code>main.js</code></p>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$EventBus = <span class="keyword">new</span> Vue()</span><br></pre></td></tr></table></figure><p>   这两种方法任选一种即可，这里我使用的是第一种方法。</p><ol start="2"><li><p>接下来就是发送事件了，比如我们要在父组件上监听子组件中的恢复按钮 <code>click</code> 事件 <code>headleClick</code> ,我们需要在子组件中引入我们的事件总线，在通过我们的 <code>eventBus.$emit()</code> ，将我们的事件发送出去</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> eventBus <span class="keyword">from</span> <span class="string">&#x27;../../utils/eventBus&#x27;</span>   <span class="comment">// 引入我们的事件总线</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    methods:&#123;</span><br><span class="line">        headleClick()&#123;</span><br><span class="line">            <span class="comment">// callReply为传递过去的事件名，可以自定义，this.parentData为传递过去的数据</span></span><br><span class="line">            eventBus.$emit(<span class="string">&#x27;callReply&#x27;</span>, <span class="built_in">this</span>.parentData)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>再就是在父组件中接收事件了，我们需要在父组件中引入我们的事件总线，在通过我们的<code>eventBus.$on</code> 来监听事件，这个事件可以接收两个参数，第一个为要监听的时间名，也就是子组件传递过来的事件名，第二个参数为一个函数，可以接收到子组件传递过来的数据，然后再函数内部处理相关的业务逻辑就可以了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">created()&#123;</span><br><span class="line">       <span class="comment">// 可以监听这个实例触发的时间</span></span><br><span class="line">       <span class="comment">// 有两个参数</span></span><br><span class="line">       <span class="comment">// 一个事件名</span></span><br><span class="line">       <span class="comment">// 回调函数，一样可以接受数据</span></span><br><span class="line">       eventBus.$on(<span class="string">&#x27;callReply&#x27;</span>,<span class="function">(<span class="params">comment</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(comment)      </span><br><span class="line">           <span class="comment">// 这里打印出来的结果就是子组件传递过来的数据，this.parentData</span></span><br><span class="line">       &#125;),</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>最后当然就是在页面销毁的时候销毁监听事件了😁，大家都知道<code>vue</code>是单页应用，如果你在某一个页面刷新了之后，与之相关的<code>EventBus</code>会被移除，这样就导致业务走不下去。还要就是如果业务有反复操作的页面，<code>EventBus</code>在监听的时候就会触发很多次，也是一个非常大的隐患。这时候我们就需要好好处理<code>EventBus</code>在项目中的关系。通常会用到，在<code>vue</code>页面销毁时，同时移除<code>EventBus</code>事件监听。我们只需要在监听事件的页面上添加下面这几行代码就可以了👇</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">destroyed() &#123;</span><br><span class="line">    <span class="comment">// 销毁时取消监听</span></span><br><span class="line">    eventBus.$off(<span class="string">&#x27;callReply&#x27;</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p> 这样，我们的整个事件总线的使用就可以达到我们想要的效果了😄</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue.js </tag>
            
            <tag> 项目总结 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

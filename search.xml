<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于英雄头条的一些感悟</title>
      <link href="2020/10/16/yxtoutiao/"/>
      <url>2020/10/16/yxtoutiao/</url>
      
        <content type="html"><![CDATA[<h1 id="英雄头条（移动端）的一些感悟"><a href="#英雄头条（移动端）的一些感悟" class="headerlink" title="英雄头条（移动端）的一些感悟"></a>英雄头条（移动端）的一些感悟</h1><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>英雄头条是一个通用信息平台，致力于连接人与信息，让优质丰富的信息得到高效精准的分发，促使信息创造价值。</p><p>英雄头条目前拥有推荐引擎、搜索引擎、关注订阅和内容运营等多种分发方式，囊括图文、视频、问答等多种内容体裁，并涵盖科技、体育、健康、美食、教育等多个内容领域。</p><p>英雄头条包括移动端前台浏览文章、个人中心、评论等页面。Pc端后台管理文章、发布文章、编辑文章等。</p><h3 id="项目原型"><a href="#项目原型" class="headerlink" title="项目原型"></a>项目原型</h3><p><a href="http://cai-yingxiong.gitee.io/yxtoutiao/#/">英雄头条前台</a>这个是前台的页面，建议在移动端上打开😜</p><p><strong>英雄头条后台因为线上的服务器数据的错乱这里就不展示了</strong>😳</p><h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><ul><li>Vue</li><li>Vue-router</li><li>Element-ui</li><li>Vue2Editor 富文本编辑器</li><li>Vant</li><li>Axios</li><li>Token</li></ul><h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>因为接触Vue的时间不长，不久前刚学习完Vue的基本使用，所以想通过该项目来加深对Vue框架的了解，其目的也是为了学习vue框架的使用，使我能从中学习到很多以后工作有用的东西，一切都是为了工作！！！💪</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>这是一个使用 <code>Vue-cli</code> 脚手架创建的项目，因为之前已经系统的学习过Vue的基本使用了，所以这里就不介绍的那么详细，就简单的总结一下通过这个项目学习到的东西和难点🤭</p><h3 id="路由守卫-导航守卫"><a href="#路由守卫-导航守卫" class="headerlink" title="路由守卫(导航守卫)"></a>路由守卫(导航守卫)</h3><p>官方解释：  正如其名，<code>vue-router</code> 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。有多种机会植入路由导航过程中：全局的, 单个路由独享的, 或者组件级的。 </p><h4 id="使用背景"><a href="#使用背景" class="headerlink" title="使用背景"></a>使用背景</h4><p>在我们登录进到一个需要 <code>token</code> 权限的网站的时候，如果本地的 token 值被删除，或者是通过另外的方法进入到该页面时，我们需要用到路由守卫，路由守卫可以理解为<strong>页面跳转之前</strong>的拦截手段，可以在拦截时判断验证用户信息，再决定是否允许用户跳转到该页面。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>在  <code>src/main.js</code>  文件里注册一个 router.beforeEach  全局前置守卫</p><p><strong>目标:</strong> 使用路由守卫, 每当跳转到个人中心的时候, 先校验 token 如果没有,重定向到登录页</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span>        <span class="comment">// 需引入router</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入了 router 以后就可以创建路由守卫</span></span><br><span class="line"><span class="comment">// beforeEach 是全局前置守卫，会拦截所有的页面跳转</span></span><br><span class="line"><span class="comment">// 接受一个回调函数作为参数，对调转进行处理</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 这个函数默认有三个参数</span></span><br><span class="line">    <span class="comment">// to 目的地的路由配置</span></span><br><span class="line">    <span class="comment">// from  来源路由配置</span></span><br><span class="line">    <span class="comment">// next  正常继续下面操作的放行函数</span></span><br><span class="line">    <span class="comment">// 判断要跳转到的页面是否为个人主页</span></span><br><span class="line">    <span class="keyword">if</span> (to.path == <span class="string">&#x27;/personage&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断本地是否存在 token</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;token&#x27;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 有登录就放行</span></span><br><span class="line">            next()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有登录就跳转到登录页</span></span><br><span class="line">            router.push(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不是跳转到个人主页就不管</span></span><br><span class="line">        next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这是在个人中心页退出到登录页时通过在导航卫士中打印的 <code>to</code> 的信息</p><p><img src="D:\前端开发\线下英雄学习\笔记汇总\学习感悟\images\router_to.png"></p><p><strong>注意点：</strong></p><p>守卫方法接收三个参数：</p><ul><li>to：代表要跳转到哪个路由（页面），我们可以通过 <code>to.path</code> 获取要跳转到的页面的地址，</li><li>from：代表从哪个路由跳转过来，<code>from.path</code> 一样可以拿到从哪个页面跳转过来的地址</li><li>next：是一个函数，必须要调用才能跳转到下一个页面，不调用则不跳转,所以一定要记得next()<ul><li>next() : 表示正常跳转到下一页</li><li><strong>(新版不能这么用)</strong>  next(“/login”) 表示重定向到指定的页面 </li><li>最新的路由, 重定向可以使用 router.push (不在组件内就没有 this.$router 了)</li></ul></li></ul><p><strong>补充</strong>:</p><p>在我们的项目中有很多个页面都是需要有权限 <code>token</code> 才能进入，所以我们这里要对 <code>to.path</code> 进行多次验证，但是像上述方法一样的话就显得代码有点冗余了，这里的话，我想到了两种方法：</p><p>第一种：</p><p>通过将所有需要进行验证的页面全都放在一个数组中，再判断 <code>to.path</code> 是否存在该数组当中即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 将所有需要校验的页面提出来，变成一个数组管理</span></span><br><span class="line">        <span class="comment">// 2、只需要判断 to.path 是否存在于数组中即可</span></span><br><span class="line">        <span class="keyword">const</span> pageNeedAuth = [</span><br><span class="line">            <span class="string">&#x27;/personage&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;/compile&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">        <span class="keyword">if</span> (pageNeedAuth.indexOf(to.path) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;token&#x27;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 有登录就放行</span></span><br><span class="line">            next()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有登录就跳转到登录页</span></span><br><span class="line">            router.push(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不是跳转到个人主页就不管</span></span><br><span class="line">        next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>第二种：</p><p>我们可以通过利用路由 meta 属性，配置是否需要登录的选项，如果要登录就设置 needAuth == true</p><p><code>src/router/index.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        path: <span class="string">&#x27;/personage&#x27;</span>, <span class="comment">// 个人中心</span></span><br><span class="line">        name: <span class="string">&#x27;Personage&#x27;</span>,</span><br><span class="line">        component: Personage,</span><br><span class="line">        meta: &#123;</span><br><span class="line">            needAuth: <span class="literal">true</span>  <span class="comment">// 需要验证</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p><code>src/main.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 利用路由 meta 属性，配置是否需要登录的选项</span></span><br><span class="line">    <span class="comment">// 判断是否需要验证</span></span><br><span class="line">    <span class="keyword">if</span> (to.path.needAuth) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;token&#x27;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 有登录就放行</span></span><br><span class="line">            next()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有登录就跳转到登录页</span></span><br><span class="line">            router.push(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不是跳转到个人主页就不管</span></span><br><span class="line">        next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样就可以，这两种方法效果都是一样的，但是个人感觉第二种方法会方便一点，比较这样的话，在进行路由配置的时候就可以对其进行需要验证的设置了，不用再找到 <code>main.js</code> 文件的路由导航部分进行添加了🤭</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结:"></a>小结:</h4><ol><li>创建路由守卫</li><li>在回调中校验权限 (是否有 token)</li><li>如果有 token 合法访问, return next();</li><li>如果没有就是非法访问, return  router.push({path:’/login’}) 跳转到登录页</li><li>最后在整个路由守卫的最下方必须有一个 next() 用来处理其他页面的情况</li><li>每个页面都会执行全局守卫</li></ol><h3 id="axios设置默认基准路径"><a href="#axios设置默认基准路径" class="headerlink" title="axios设置默认基准路径"></a>axios设置默认基准路径</h3><h4 id="使用背景-1"><a href="#使用背景-1" class="headerlink" title="使用背景"></a>使用背景</h4><p>每次发送请求的时候都要添加服务器地址的问题：</p><ol><li>重复、太麻烦了…</li><li>假如有一天,你的服务器搬迁了, 换服务器了, 比如从在线的变成本地的 http:127.0.0.1:3000，维护起来就很麻烦</li></ol><h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h4><p>我们可以提取请求的统一的服务器域名的部分进行抽离设置</p><p>在 <code>main.js</code> 文件中 里面设置 <code>axios.defaults.baseURL</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axios.dafaults.baseURL = <span class="string">&#x27;http://157.122.54.189:9083&#x27;</span>    <span class="comment">// 在线的服务器</span></span><br><span class="line"><span class="comment">// axios.dafaults.baseURL = &#x27;http://127.0.0.1：3000&#x27;        // 本地服务器</span></span><br></pre></td></tr></table></figure><p>这样，我们在发送请求的时候，就不用再写服务器地址了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$axios(&#123;</span><br><span class="line">url:<span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">data:&#123;&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="axios拦截器"><a href="#axios拦截器" class="headerlink" title="axios拦截器"></a>axios拦截器</h3><p>在请求或响应被 <code>then</code> 或 <code>catch</code> 函数处理前拦截它们</p><h4 id="使用背景-2"><a href="#使用背景-2" class="headerlink" title="使用背景"></a>使用背景</h4><p>如果用户使用错误的 <code>token</code> 绕过了全局导航守卫，进入了页面，页面会发送请求，如果响应的是用户信息验证失败，就应该在页面内部进行跳转，如果每个页面都这么写的话，就比较烦。而且，在我们发送请求的时候，大多都是要经过验证的，也就是在发送请求的时候，需要在请求头 <code>headers</code> 中添加验证信息 <code>token</code> ,但是每个请求都写就显得有点烦人了🤯，所以这里用我们 axios 的拦截器来做再合适不过了。</p><h4 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h4><p>附上图解</p><p><img src="D:\前端开发\线下英雄学习\笔记汇总\学习感悟\images\axios.png"></p><p><code>src/main.js</code> 文件中</p><ol><li>因为需要统一处理错误, 所以是全局的, 再 main.js 当中声明拦截器</li><li><code>axios.interceptors.resquest.use()</code>声明一个请求拦截器, 可以接受一个回调函数做参数, 带有请求数据 config ， 响应拦截器的声明方法只要将上述方法中的 <code>request</code> 更改为 <code>response</code> 就可以了，一样可以接收一个回调函数做参数，带有响应数据 res</li><li>拦截器拦截数据, 处理后必须放行 (return)</li><li>将我们的错误逻辑从 .then 抽离出来放到响应拦截器里面</li></ol><h5 id="请求拦截器"><a href="#请求拦截器" class="headerlink" title="请求拦截器"></a>请求拦截器</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里可以接收一个形参，拿到当前请求的配置</span></span><br><span class="line">    <span class="comment">// 如果本地存在 token 并且 请求数据中没有设置 token 就拦截下来给请求头添加 token</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;token&#x27;</span>) &amp;&amp; !config.headers.Authorization) &#123;</span><br><span class="line">        config.headers.Authorization = <span class="string">&quot;Bearer &quot;</span> + <span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 继续发送请求</span></span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="响应拦截器"><a href="#响应拦截器" class="headerlink" title="响应拦截器"></a>响应拦截器</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// res 为发送请求后返回的数据</span></span><br><span class="line">    <span class="comment">// 判断进来的用户是否有权限</span></span><br><span class="line">    <span class="keyword">if</span> (res.data.message == <span class="string">&#x27;用户信息验证失败&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 清除错误数据，再跳转</span></span><br><span class="line">        <span class="built_in">localStorage</span>.clear()</span><br><span class="line">        router.replace(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 除了明确用户信息验证失败跳转到登录页以外</span></span><br><span class="line">    <span class="comment">// 还可以封装其他的通用处理，比如 状态码 statusCode 是以4开头的三位数的请求</span></span><br><span class="line">    <span class="comment">// 不知道如何处理的情况下，只需统一将 message 给提示出来就可以了</span></span><br><span class="line">    <span class="comment">// 统一处理发送请求错误</span></span><br><span class="line">    <span class="keyword">const</span> reg = <span class="regexp">/^4\d&#123;2&#125;$/</span></span><br><span class="line">    <span class="keyword">if</span> (reg.test(res.data.statusCode)) &#123;</span><br><span class="line">        Toast.fail(res.data.message)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>注意点</strong></p><ol><li><p><code>src/main.js</code> 文件中如果想使用 vant 组件的话，因为之前的配置是全局的，在这里是不能用的，所以要单独引入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Toast &#125; from &#39;vant&#39;</span><br></pre></td></tr></table></figure></li><li><p>在不知道是否为错误的情况下，检查 res.data.statusCode 如果存在并且是 4 开头的三位数, 那么就可以证明出错</p></li><li><p>记得处理拦截后必须放行, 不然就卡死在这了</p></li><li><p><strong>导航守卫(路由守卫) 跟 响应拦截器 容易混淆, 但是作用很不一样, 特别是生效时间点</strong></p></li></ol><p><img src="D:\前端开发\线下英雄学习\笔记汇总\学习感悟\images\axios_router.png"></p><h3 id="首页Tab-标签页和文章组件的使用"><a href="#首页Tab-标签页和文章组件的使用" class="headerlink" title="首页Tab 标签页和文章组件的使用"></a>首页Tab 标签页和文章组件的使用</h3><p>这里首页的主要内容是依靠 Vant 组件库中的Tab标签页组件 配合 自己封装的文章组件完成的。这里还添加了 Vant组件库的 List组件，实现下拉加载更多功能，并做了优化处理，所以自己认为对初学者的我还是有一定的难度的😁</p><p>这里附上 <a href="https://youzan.github.io/vant/#/zh-CN/">Vant组件库的地址</a></p><p>这是我自己封装的首页文章组件</p><p>忽略其中的样式和 js 部分</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">&quot;$router.push(`/postdetail?id=$&#123;postData.id&#125;`)&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 专门显示单图片新闻 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 1. type == 1</span></span><br><span class="line"><span class="comment">      2. cover.length &gt;=1 &amp;&amp; &lt; 3 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">            </span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">&quot;singleNews&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">v-if</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">                postData.type == 1 &amp;&amp;</span></span></span><br><span class="line"><span class="tag"><span class="string">                postData.cover.length &gt;= 1 &amp;&amp;</span></span></span><br><span class="line"><span class="tag"><span class="string">                postData.cover.length &lt; 3</span></span></span><br><span class="line"><span class="tag"><span class="string">            &quot;</span></span></span><br><span class="line"><span class="tag">        &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span></span><br><span class="line">                    &#123;&#123; postData.title &#125;&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">                    &#123;&#123; postData.user.nickname &#125;&#125;</span><br><span class="line">                    &#123;&#123; postData.comment_length &#125;&#125; 跟帖</span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;fnFixImgUrl(postData.cover[0].url)&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cover&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 专门显示多图片新闻 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 1. type == 1</span></span><br><span class="line"><span class="comment">      2. cover.length &gt;= 3 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">            </span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">&quot;multipNews&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">v-if</span>=<span class="string">&quot;postData.type == 1 &amp;&amp; postData.cover.length &gt;= 3&quot;</span></span></span><br><span class="line"><span class="tag">        &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span>&#123;&#123; postData.title &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;coversWrapper&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;cover&quot;</span> <span class="attr">:src</span>=<span class="string">&quot;fnFixImgUrl(postData.cover[0].url)&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;cover&quot;</span> <span class="attr">:src</span>=<span class="string">&quot;fnFixImgUrl(postData.cover[1].url)&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;cover&quot;</span> <span class="attr">:src</span>=<span class="string">&quot;fnFixImgUrl(postData.cover[2].url)&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">                &#123;&#123; postData.user.nickname &#125;&#125; &#123;&#123; postData.comment_length &#125;&#125; 跟帖</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 专门显示视频 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 1. type == 2</span></span><br><span class="line"><span class="comment">      2. 封面最少有一张 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">            </span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">&quot;singleVideo&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">v-if</span>=<span class="string">&quot;postData.type == 2 &amp;&amp; postData.cover.length &gt;= 1&quot;</span></span></span><br><span class="line"><span class="tag">        &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span>&#123;&#123; postData.title &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;coverWrapper&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;fnFixImgUrl(postData.cover[0].url)&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cover&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;iconfont iconshipin&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">                &#123;&#123; postData.user.nickname &#125;&#125; &#123;&#123; postData.comment_length &#125;&#125; 跟帖</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>想要让我们的组件显示只要传入一个 <code>postData</code> 单个文章数据就能渲染出来，配合我们 Vant 中的tab标签页组件使用正常渲染问题都不大，</p><h4 id="问题说明"><a href="#问题说明" class="headerlink" title="问题说明"></a>问题说明</h4><p>但是也存在一个致命的问题，那就是，我们每一次切换页面都要发送请求，不管是否浏览过该栏目都会再次发送请求，这样的话，对服务器造成的负担会比较大。所以，这里要进行一下优化</p><p>实现方法：</p><ol><li><p>在页面获取所有的栏目时，在给每一个栏目数据添加一个空的数组来放置相应的文章列表数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">getcategoryList()&#123;</span><br><span class="line">      <span class="built_in">this</span>.$axios(&#123;</span><br><span class="line">        url:<span class="string">&#x27;/category&#x27;</span>     <span class="comment">// 获取所有的栏目数据</span></span><br><span class="line">      &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.categoryList = res.data.data.map(<span class="function"><span class="params">category</span> =&gt;</span>&#123;</span><br><span class="line">          <span class="keyword">return</span>&#123;</span><br><span class="line">            ...category,</span><br><span class="line">            <span class="comment">// 在获取文章分类时添加 postList空数组来存储文章列表数组</span></span><br><span class="line">            postList: [],</span><br><span class="line">            pageIndex:<span class="number">1</span>, <span class="comment">// 当前页数</span></span><br><span class="line">            pageSize:<span class="number">5</span>,  <span class="comment">// 每页数据条数</span></span><br><span class="line">            loading:<span class="literal">false</span>,  <span class="comment">// 当前是否在加载中</span></span><br><span class="line">            finished:<span class="literal">false</span>, <span class="comment">// 是否加载完毕</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">         <span class="comment">// 加载相应的文章数据</span></span><br><span class="line">        <span class="built_in">this</span>.loadPost()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure></li><li><p>在每次激活该栏目的时候，在获取到相应的文章数据时，就将相应的文章数据添加到相应的栏目生成的空数组 <code>postList</code> 中,如果有新的文章就将新的数据拼接在之前的数据后面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">loadPost()&#123;</span><br><span class="line">      <span class="built_in">this</span>.$axios(&#123;</span><br><span class="line">        url:<span class="string">&#x27;/post&#x27;</span>,</span><br><span class="line">        params:&#123;</span><br><span class="line">          <span class="comment">// 传入文章分类的id</span></span><br><span class="line">          category:<span class="built_in">this</span>.curCate.id,</span><br><span class="line">          pageIndex:<span class="built_in">this</span>.curCate.pageIndex, <span class="comment">// 当前页数</span></span><br><span class="line">          pageSize:<span class="built_in">this</span>.curCate.pageSize, </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 将获取到的文章列表添加到文章分类中对应的位置中去</span></span><br><span class="line">        <span class="built_in">this</span>.curCate.postList = [</span><br><span class="line">          ...this.curCate.postList,</span><br><span class="line">          ...res.data.data</span><br><span class="line">        ]</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure></li><li><p>在我们监听到了分类栏目发生变化的时候，我们要进行相应的判断，当前栏目分类的 <code>postList</code> 是否存在文章列表数据，若是不存在，再发送请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">activeIndex()&#123;</span><br><span class="line">       <span class="comment">// 这里检测到分类切换，加载新分类数据</span></span><br><span class="line">        <span class="comment">// 但是，由于我们已经分栏目管理数据了</span></span><br><span class="line">        <span class="comment">// 只有文章不存在时才会发送请求获取文章列表</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.curCate.postList.length == <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="built_in">this</span>.loadPost()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样，我们就可以达到我们要的效果了🤭</p></li></ol><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>其实这个在完成项目完成之后，回过头来看就觉得也不是很难，主要是数据有点复杂，一层套一层，刚开始敲的时候很难理清楚。索性最后还是理清楚了🤭</p><h3 id="递归组件实现评论模块"><a href="#递归组件实现评论模块" class="headerlink" title="递归组件实现评论模块"></a>递归组件实现评论模块</h3><p>说起递归组件，对于一个初学者还是有一定的威慑力的😜，这里作为回顾的话，就把递归也一起复习一下吧</p><h4 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a>什么是递归</h4><p>递归就是一个函数直接或间接的调用自己，我们在使用的时候一定要让它能够停下来，否则停不下来的话会出事喔🤭</p><h4 id="什么是递归组件"><a href="#什么是递归组件" class="headerlink" title="什么是递归组件"></a>什么是递归组件</h4><p>其实递归组件跟递归是差不多的，只是递归是函数自身的调用，而递归组件则是组件在满足一定的条件下组件内部调用自身，话不多说，直接上代码👇</p><p><img src="D:\前端开发\线下黑马学习\笔记汇总\学习感悟\images\comment.png"></p><p><img src="D:\前端开发\线下黑马学习\笔记汇总\学习感悟\images\commentList.png"></p><h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><p>这是我们从服务器拿到的数据还有我们要实现的样式，一个评论里面还有可能在嵌套多一个评论数据 <code>parent</code> 。所以我们的递归组件的条件便是这个 <code>parent</code> 是否存在，又考虑到这个最外部的主评论的样式中还包括了其他的一些样式，所以我们这里就创建了两个组件，一个父组件编写最外层的主评论，子组件来完成评论内部的递归组件。父组件中嵌套子组件，来完成我们的评论列表的渲染</p><p>子组件结构如下👇</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parentWrapper&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">Parent</span> <span class="attr">v-if</span>=<span class="string">&quot;parentData.parent&quot;</span> <span class="attr">:parentData</span>=<span class="string">&quot;parentData.parent&quot;</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;name&quot;</span>&gt;</span>&#123;&#123; parentData.user.nickname &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;date&quot;</span>&gt;</span>3小时前<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;btnReply&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;headleClick&quot;</span>&gt;</span>回复<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ParentContent&quot;</span>&gt;</span></span><br><span class="line">              &#123;&#123; parentData.content &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意点</strong></p><p>组件内部调用自身，要记得给自身设置 <code>name</code> 属性</p><h3 id="事件总线EventBus"><a href="#事件总线EventBus" class="headerlink" title="事件总线EventBus"></a>事件总线EventBus</h3><h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><p>在Vue中可以使用 <code>EventBus</code> 来作为沟通桥梁的概念，就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件，所以组件都可以上下平行地通知其他组件，但也就是太方便所以若使用不慎，就会造成难以维护的灾难，因此才需要更完善的Vuex作为状态管理中心，将通知的概念上升到共享状态层次 </p><h4 id="使用背景-3"><a href="#使用背景-3" class="headerlink" title="使用背景"></a>使用背景</h4><p>由于递归组件的多层嵌套，我们在完成评论的发布功能的时候传递数据和响应事件就显的特别麻烦，但是这个时候我还没有学习vuex，所以就使用到了事件总线 <code>EventBus</code> </p><h4 id="使用方法-3"><a href="#使用方法-3" class="headerlink" title="使用方法"></a>使用方法</h4><ol><li>创建事件总线并将其导出，以便其它模块可以使用或者监听它。我们可以通过两种方式来实现。先来看第一种，新创建一个js文件，比如 <code>eventBus.js</code> ,第二种方法就是直接在 <code>main.js</code> 文件中初始化 <code>eventBus</code></li></ol><p>   <code>ulit/eventBus.js</code></p>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里创建一个 vue 实例</span></span><br><span class="line"><span class="comment">// 作为公共事件总线 eventBus</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> eventBus = <span class="keyword">new</span> Vue()</span><br><span class="line"><span class="comment">// 将这个实例导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> eventBus</span><br></pre></td></tr></table></figure><p>   <code>main.js</code></p>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$EventBus = <span class="keyword">new</span> Vue()</span><br></pre></td></tr></table></figure><p>   这两种方法任选一种即可，这里我使用的是第一种方法。</p><ol start="2"><li><p>接下来就是发送事件了，比如我们要在父组件上监听子组件中的恢复按钮 <code>click</code> 事件 <code>headleClick</code> ,我们需要在子组件中引入我们的事件总线，在通过我们的 <code>eventBus.$emit()</code> ，将我们的事件发送出去</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> eventBus <span class="keyword">from</span> <span class="string">&#x27;../../utils/eventBus&#x27;</span>   <span class="comment">// 引入我们的事件总线</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    methods:&#123;</span><br><span class="line">        headleClick()&#123;</span><br><span class="line">            <span class="comment">// callReply为传递过去的事件名，可以自定义，this.parentData为传递过去的数据</span></span><br><span class="line">            eventBus.$emit(<span class="string">&#x27;callReply&#x27;</span>, <span class="built_in">this</span>.parentData)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>再就是在父组件中接收事件了，我们需要在父组件中引入我们的事件总线，在通过我们的<code>eventBus.$on</code> 来监听事件，这个事件可以接收两个参数，第一个为要监听的时间名，也就是子组件传递过来的事件名，第二个参数为一个函数，可以接收到子组件传递过来的数据，然后再函数内部处理相关的业务逻辑就可以了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">created()&#123;</span><br><span class="line">       <span class="comment">// 可以监听这个实例触发的时间</span></span><br><span class="line">       <span class="comment">// 有两个参数</span></span><br><span class="line">       <span class="comment">// 一个事件名</span></span><br><span class="line">       <span class="comment">// 回调函数，一样可以接受数据</span></span><br><span class="line">       eventBus.$on(<span class="string">&#x27;callReply&#x27;</span>,<span class="function">(<span class="params">comment</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(comment)      </span><br><span class="line">           <span class="comment">// 这里打印出来的结果就是子组件传递过来的数据，this.parentData</span></span><br><span class="line">       &#125;),</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>最后当然就是在页面销毁的时候销毁监听事件了😁，大家都知道<code>vue</code>是单页应用，如果你在某一个页面刷新了之后，与之相关的<code>EventBus</code>会被移除，这样就导致业务走不下去。还要就是如果业务有反复操作的页面，<code>EventBus</code>在监听的时候就会触发很多次，也是一个非常大的隐患。这时候我们就需要好好处理<code>EventBus</code>在项目中的关系。通常会用到，在<code>vue</code>页面销毁时，同时移除<code>EventBus</code>事件监听。我们只需要在监听事件的页面上添加下面这几行代码就可以了👇</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">destroyed() &#123;</span><br><span class="line">    <span class="comment">// 销毁时取消监听</span></span><br><span class="line">    eventBus.$off(<span class="string">&#x27;callReply&#x27;</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p> 这样，我们的整个事件总线的使用就可以达到我们想要的效果了😄</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目总结 </tag>
            
            <tag> Vue.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数防抖和函数节流</title>
      <link href="2020/10/13/debounce-throttle/"/>
      <url>2020/10/13/debounce-throttle/</url>
      
        <content type="html"><![CDATA[<h1 id="函数防抖和节流"><a href="#函数防抖和节流" class="headerlink" title="函数防抖和节流"></a>函数防抖和节流</h1><h2 id="函数防抖（debounce）"><a href="#函数防抖（debounce）" class="headerlink" title="函数防抖（debounce）"></a>函数防抖（debounce）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>函数防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。</p><p>简单点说就是：用户连续多次触发某个事件，则只执行最后一次</p><p>就比如我们之前敲过的 手风琴案例 如果用户鼠标轻微晃动，在某个元素上停留时间很短，则认为是用户误触发，则不执行本次事件处理函数</p><p>未添加函数防抖之前的手风琴动画</p><p><img src="https://pic.downk.cc/item/5f8596901cd1bbb86bc74d78.gif"></p><p> 根据上图，我们不难发现，在用户想移动至某个元素途中，经过了很多元素，被鼠标移入的元素都执行了动画，但这些其实都不是用户想要看到的，这就是所谓的函数抖动</p><p>添加了函数防抖之后的手风琴</p><p><img src="https://pic.downk.cc/item/5f85979d1cd1bbb86bc7ff4e.gif"></p><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>这是我们最原始的j代码</p><p>html、css部分</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">        * &#123;</span><br><span class="line">            <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">            <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="selector-tag">ul</span> &#123;</span><br><span class="line">            <span class="attribute">list-style</span>: none;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">2400px</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="selector-id">#box</span> &#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">1200px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">            <span class="attribute">border</span>: <span class="number">2px</span> solid red;</span><br><span class="line">            <span class="attribute">margin</span>: <span class="number">100px</span> auto;</span><br><span class="line">            <span class="attribute">overflow</span>: hidden;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="selector-id">#box</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">240px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">            <span class="attribute">float</span>: left;</span><br><span class="line">        &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./images/collapse/1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./images/collapse/2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./images/collapse/3.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./images/collapse/4.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./images/collapse/5.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height:150px;line-height:150px;text-align:center; color: #fff;background-color:#ccc;font-size:80px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>js部分代码</p><p>其中 animationSlow 是我封装的一个缓动动画，调用方法为 animationSlow(“需要进行动画的dom对象”,”需要进行修改的样式，是一个对象类型”)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入我们自己封装的缓动动画</span></span><br><span class="line">&lt;script src=<span class="string">&quot;./animationSlow.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#box&#x27;</span>);              <span class="comment">// 这是最外面的大盒子</span></span><br><span class="line"><span class="keyword">var</span> liList = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;#box li&#x27;</span>);     <span class="comment">// 这是里面的每一个商品</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.注册事件</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.1 li元素注册鼠标移入事件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; liList.length; i++) &#123;</span><br><span class="line">            liList[i].onmouseenter = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">//3. 排他思想 </span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; liList.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (liList[j] == <span class="built_in">this</span>) &#123;</span><br><span class="line">                        animationSlow(liList[j], &#123;</span><br><span class="line">                            width: <span class="number">800</span></span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        animationSlow(liList[j], &#123;</span><br><span class="line">                            width: <span class="number">100</span></span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.2 给box注册鼠标移出事件</span></span><br><span class="line">        box.onmouseleave = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; liList.length; j++) &#123;</span><br><span class="line">                animationSlow(liList[j], &#123;</span><br><span class="line">                    width: <span class="number">240</span></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>分析思路：</p><ol><li>声明全局变量存储定时器ID</li><li>触发事件的时候，不立即执行，而是开启定时器，过一段时间触发</li><li>用户连续触发事件的时候，清除之前的定时器，全局变量只会存储最后一次触发的事件定时器（前面的都会被清除掉，认为这是用户误操作产生抖动）</li></ol><p><strong>注意点：在定时器内部的 <code>this</code> 关键字，无条件指向window，所以我们这里要记得使用 <code>bind</code> 重新修改定时器中的 <code>this</code> 指向</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明全局变量存储定时器ID</span></span><br><span class="line"><span class="keyword">var</span> timeId = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.1 li元素注册鼠标移入事件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; liList.length; i++) &#123;</span><br><span class="line">            liList[i].onmouseenter = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 每次被触发事件前都要清除之前的定时器，保证只执行最后一次</span></span><br><span class="line">                <span class="built_in">clearInterval</span>(timeId)</span><br><span class="line">                <span class="comment">// 触发事件的时候，不立即执行，而是开启定时器，过一段时间触发</span></span><br><span class="line">                timeId = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; liList.length; j++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (liList[j] == <span class="built_in">this</span>) &#123;</span><br><span class="line">                                animationSlow(liList[j], &#123;</span><br><span class="line">                                    width: <span class="number">800</span></span><br><span class="line">                                &#125;);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                animationSlow(liList[j], &#123;</span><br><span class="line">                                    width: <span class="number">100</span></span><br><span class="line">                                &#125;);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;.bind(<span class="built_in">this</span>), <span class="number">500</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.2 给box注册鼠标移出事件</span></span><br><span class="line">        box.onmouseleave = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">            <span class="built_in">clearInterval</span>(timeId)</span><br><span class="line">            timeId = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; liList.length; j++) &#123;</span><br><span class="line">                        animationSlow(liList[j], &#123;</span><br><span class="line">                            width: <span class="number">240</span></span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;;</span><br><span class="line">            &#125;.bind(<span class="built_in">this</span>), <span class="number">500</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这样，简单的函数防抖就可以实现了</p><h3 id="封装一个简单的万能防抖函数"><a href="#封装一个简单的万能防抖函数" class="headerlink" title="封装一个简单的万能防抖函数"></a>封装一个简单的万能防抖函数</h3><ol><li><p>函数防抖需要使用定时器id，这个id不能是局部的（函数走完之后会被回收）</p></li><li><p>定时器id也不能是全局的，因为会造成全局变量污染，所以我们要尽量避免使用全局变量</p></li><li><p>解决方案：</p><p>（1）使用闭包延长局部变量生命周期，但是闭包语法很繁琐 </p><p>（2）利用函数本身也是对象，使用函数自身的静态成员来存储定时器ID</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, time</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 开启定时器之前先清除掉之前的定时器 </span></span><br><span class="line">    <span class="built_in">clearInterval</span>(debounce.timeId)</span><br><span class="line"> <span class="comment">// 开启定时器，时间间隔触发</span></span><br><span class="line">    debounce.timeId = <span class="built_in">setInterval</span>(fn, time)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就完成了一个简单的万能防抖函数的封装</p><p>我们实际使用一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; liList.length; i++) &#123;</span><br><span class="line">     liList[i].onmouseenter = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="comment">//3. 排他思想 </span></span><br><span class="line">         debounce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">             <span class="comment">// clearInterval(timeId)</span></span><br><span class="line">             <span class="comment">// timeId = setInterval(function() &#123;</span></span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; liList.length; j++) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (liList[j] == <span class="built_in">this</span>) &#123;</span><br><span class="line">                     animationSlow(liList[j], &#123;</span><br><span class="line">                         width: <span class="number">800</span></span><br><span class="line">                     &#125;);</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     animationSlow(liList[j], &#123;</span><br><span class="line">                         width: <span class="number">100</span></span><br><span class="line">                     &#125;);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;.bind(<span class="built_in">this</span>), <span class="number">500</span>)</span><br><span class="line">     &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用闭包封装一个万能防抖函数"><a href="#使用闭包封装一个万能防抖函数" class="headerlink" title="使用闭包封装一个万能防抖函数"></a>使用闭包封装一个万能防抖函数</h3><h4 id="网上常见的一个防抖函数"><a href="#网上常见的一个防抖函数" class="headerlink" title="网上常见的一个防抖函数"></a>网上常见的一个防抖函数</h4><p>这个是未防抖之前的代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height:150px;line-height:150px;text-align:center; color: #fff;background-color:#ccc;font-size:80px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> num = <span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> content = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;content&#x27;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">        content.innerHTML = num++;</span><br><span class="line">    &#125;;</span><br><span class="line">    content.onmousemove = count;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个是还未添加防抖的效果演示</p><p><img src="https://upload-images.jianshu.io/upload_images/4842858-652a8eb5c73db0c7.gif"></p><p>这是网上常见的防抖函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> timeout;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">                <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">                <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">                timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    func.apply(context, args)</span><br><span class="line">                &#125;, wait)</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>使用防抖函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content.onmousemove = debounce(count,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>添加防抖函数之后的效果</p><p><img src="https://upload-images.jianshu.io/upload_images/4842858-1f6389b9dd9e5ef9.gif"></p><p>那就让我们用网上的这个防抖函数进行试验</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; liList.length; i++) &#123;</span><br><span class="line">            liList[i].onmouseenter = debounce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">//3. 排他思想 </span></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">                <span class="comment">// clearInterval(timeId)</span></span><br><span class="line">                <span class="comment">// timeId = setInterval(function() &#123;</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; liList.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (liList[j] == <span class="built_in">this</span>) &#123;</span><br><span class="line">                        animationSlow(liList[j], &#123;</span><br><span class="line">                            width: <span class="number">800</span></span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        animationSlow(liList[j], &#123;</span><br><span class="line">                            width: <span class="number">100</span></span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">500</span>)</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>效果演示</p><p><img src="https://pic.downk.cc/item/5f8597df1cd1bbb86bc828a9.gif"></p><h5 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h5><p>我们会发现：定时器是添加了，是在 500ms 后执行，但是，为什么经过的每一个元素都会执行，而不会被清除呢？</p><p>这是因为闭包语法的特性，在我们利用 <code>for</code> 循环给每一个元素添加鼠标移入事件的时候就已经给每一个元素添加了定时器，所以，我们在这里的话，要使用函数的静态成员来存储定时器才能保证我们只声明了一个定时器，不会出现上面的情况</p><h4 id="改良后的防抖函数"><a href="#改良后的防抖函数" class="headerlink" title="改良后的防抖函数"></a>改良后的防抖函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, time</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">let</span> that = <span class="built_in">this</span></span><br><span class="line">                <span class="keyword">let</span> args = <span class="built_in">arguments</span> <span class="comment">// arguments方法可以拿到传入的所有参数,</span></span><br><span class="line">                <span class="keyword">if</span> (debounce.timeId) <span class="built_in">clearTimeout</span>(debounce.timeId);</span><br><span class="line">                debounce.timeId = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 注意我们这里其实是可以使用箭头函数的，</span></span><br><span class="line">                <span class="comment">//就可以直接使用apply方法指向this，</span></span><br><span class="line">                <span class="comment">//而不用在定时器外面存储当前的this指向</span></span><br><span class="line">                fn.apply(that, args) </span><br><span class="line">                <span class="comment">// apply方法的第一个参数是 重定向的this指向，第二个对象是 传给fn函数 的参数</span></span><br><span class="line">                &#125;, time)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>使用上面改良的防抖函数就可以实现函数防抖了，使用方法是一样的</p><h5 id="小结：-1"><a href="#小结：-1" class="headerlink" title="小结："></a>小结：</h5><h2 id="函数节流（throttle）"><a href="#函数节流（throttle）" class="headerlink" title="函数节流（throttle）"></a>函数节流（throttle）</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>限制一个函数在一定时间内只能执行一次。</p><p>简单点说就是：让一个事件，在单位时间（500ms）内，只能执行一次</p><h3 id="函数节流的作用"><a href="#函数节流的作用" class="headerlink" title="函数节流的作用"></a>函数节流的作用</h3><p>函数节流是用来限制高频事件的触发频率的，那什么是高频事件呢？</p><ul><li><p>高频事件：触发频率极高的事件。例如  <code>onmousemove</code> (鼠标移动)、<code>onscroll</code> (滚动条事件)、<code>onresize</code> (大小变化事件)</p><p>特殊情况：高频触发（事件本身不是高频，但是用户可以通过手速来实现高频触发，例如抢购按钮的疯狂点击）</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line"><span class="built_in">window</span>.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    num ++</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我被触发了&#x27;</span>+num+<span class="string">&#x27;次&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果演示</p><p><img src="https://pic.downk.cc/item/5f85982e1cd1bbb86bc8506b.gif"></p><p>你会发现：我们在浏览器中移动了一下，事件就触发了几十上百次</p><h4 id="高频事件的危害："><a href="#高频事件的危害：" class="headerlink" title="高频事件的危害："></a>高频事件的危害：</h4><ol><li>浪费资源，降低网页速度，甚至导致浏览器卡死</li></ol><p>​    由于高频事件触发非常频繁，可能1秒会执行几十次甚至上百次，如果在这些函数内部，又调用了其他函数，尤其是操作了DOM（DOM操作耗性能且可能导致浏览器出现回流），不仅会降低整个网页的运行速，甚至会造成浏览器卡死，奔溃</p><ol><li>网速堵塞</li></ol><p>​     如果在高频事件中，进行了重复的ajax请求，可能会导致请求数据出现混乱，并且还占用服务器宽带增加服务器压力（间接增加服务器成本）</p><h3 id="函数节流思路"><a href="#函数节流思路" class="headerlink" title="函数节流思路"></a>函数节流思路</h3><ol><li>声明变量 记录 当前时间</li><li>判断当前触发事件的时间间隔</li><li>时间触发成功后，存储当前时间，作为下次触发事件的参照时间</li></ol><p>拓展：这里判断时间间隔我们要用到时间戳，那什么是时间戳呢？</p><p>​           时间戳就是来统一全球的时间的一个数字，指的是格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数，是一个非常大的数字，单位是毫秒(ms)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line"><span class="built_in">window</span>.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前的时间戳</span></span><br><span class="line">    <span class="keyword">let</span> currentTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">    <span class="comment">// 判断是否已经间隔500ms</span></span><br><span class="line">    <span class="keyword">if</span>(currentTime - lastTime &gt;<span class="number">500</span>)&#123;</span><br><span class="line">        num ++</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我被触发了&#x27;</span>+num+<span class="string">&#x27;次&#x27;</span>)</span><br><span class="line">        <span class="comment">// 将当前时间作为下次触发事件的参考时间</span></span><br><span class="line">        lastTime = currentTime</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="封装一个简单的万能节流函数"><a href="#封装一个简单的万能节流函数" class="headerlink" title="封装一个简单的万能节流函数"></a>封装一个简单的万能节流函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn,time</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否存在 throttle.lastTime 不存在就声明为0，否则在使用的时候就会自动转成 NaN </span></span><br><span class="line">    <span class="keyword">if</span>(!throttle.lastTime)&#123;</span><br><span class="line">        <span class="keyword">let</span> throttle = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前的时间戳</span></span><br><span class="line">    <span class="keyword">let</span> currentTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">    <span class="keyword">if</span>(currentTime - throttle.lastTime &gt;=time) &#123;</span><br><span class="line">        fn()</span><br><span class="line">        <span class="comment">// 将当前的时间戳赋值给 throttle.lastTime 作为下次触发事件的参考时间</span></span><br><span class="line">        throttle.lastTime = currentTime</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，一个简单的万能节流函数就完成了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line"><span class="built_in">window</span>.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    throttle(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        num ++</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我被触发了&#x27;</span>+num+<span class="string">&#x27;次&#x27;</span>)</span><br><span class="line">    &#125;,<span class="number">500</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果演示</p><p><img src="https://pic.downk.cc/item/5f85999d1cd1bbb86bc92896.gif"></p><p>调用我们封装的万能节流函数，你会发现，我们在浏览器中不管你怎么移动，我们都是 在500ms内执行一次</p><h4 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h4><p>1.节流函数需要使用使用变量存储上一次触发事件，不能是局部的（函数走完就被回收）<br>2.这个变量也不能是全局的，造成全局变量污染<br>3.解决方案：利用函数本身也是对象，使用函数的静态成员来存储 上一个触发时间</p><h3 id="使用闭包封装一个万能节流函数"><a href="#使用闭包封装一个万能节流函数" class="headerlink" title="使用闭包封装一个万能节流函数"></a>使用闭包封装一个万能节流函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, time</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 外部函数声明局部变量 lastTime </span></span><br><span class="line">            <span class="keyword">let</span> lastTime = <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 获取当前的时间戳</span></span><br><span class="line">                <span class="keyword">let</span> currentTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">                <span class="keyword">if</span> (currentTime - lastTime &gt;= time) &#123;</span><br><span class="line">                    fn()</span><br><span class="line">                    <span class="comment">// 将当前的时间戳赋值给 throttle.lastTime 作为下次触发事件的参考时间</span></span><br><span class="line">                    lastTime = currentTime</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>调用使用闭包封装的节流函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onmousemove = throttle(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            num++</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;我被触发了&#x27;</span> + num + <span class="string">&#x27;次&#x27;</span>)</span><br><span class="line">        &#125;, <span class="number">500</span>)</span><br></pre></td></tr></table></figure><p>我们会发现效果都是一样的</p><p><strong>注意闭包语法的使用，需要多次使用的变量需要在外部函数声明</strong></p><h2 id="函数防抖和函数节流的简单总结"><a href="#函数防抖和函数节流的简单总结" class="headerlink" title="函数防抖和函数节流的简单总结"></a>函数防抖和函数节流的简单总结</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ol><li>函数防抖：用户多次触发事件，以最后一次为准</li><li>函数节流：限制事件的执行周期（500ms内只会执行一次</li></ol><h3 id="函数防抖与函数节流异同点-与-应用场景"><a href="#函数防抖与函数节流异同点-与-应用场景" class="headerlink" title="函数防抖与函数节流异同点 与 应用场景"></a>函数防抖与函数节流异同点 与 应用场景</h3><ol><li><p>相同点：都是为了优化 js 代码的执行频率，提高代码性能</p></li><li><p>不同点：</p><p><strong>函数防抖</strong>：由用户需求决定</p><p>​        应用场景：鼠标的移入移出，用户快速移动鼠标，应该等用户结束移动后，以最后一次为主</p><p>​                          输入框事件：验证手机号或邮箱，用户输入时不断触发键盘事件，应该等用户结束输入之                          后，以最后一次输入为准</p><p><strong>函数节流</strong>：由事件本身决定（高频事件）</p><p>​         应用场景：onscroll（滚动条事件）</p><p>​                           onmousemove（鼠标移动）</p><p>​                           特殊情况：高频触发（抢购按钮点击，本身不是高频事件，用户可以用手速实现点击高频）</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
